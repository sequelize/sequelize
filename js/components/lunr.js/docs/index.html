<head>
  <script>
    var raw = [{"id":"0-1361873428988","name":"lunr","signiture":"lunr()","type":"function","ctx":{"type":"function","name":"lunr","string":"lunr()"},"description":{"full":"<p>Convinience function for instantiating a new lunr index and configuring it<br />with the default pipeline functions and the passed config function.</p>\n\n<p>When using this convinience function a new index will be created with the<br />following functions already in the pipeline:</p>\n\n<p>lunr.StopWordFilter - filters out any stop words before they enter the<br />index</p>\n\n<p>lunr.stemmer - stems the tokens before entering the index.</p>\n\n<p>Example:</p>\n\n<pre><code>var idx = lunr(function () {\n  this.field('title', 10)\n  this.field('tags', 100)\n  this.field('body')\n\n  this.ref('cid')\n\n  this.pipeline.add(function () {\n    // some custome pipeline function\n  })\n\n})\n</code></pre>","summary":"<p>Convinience function for instantiating a new lunr index and configuring it<br />with the default pipeline functions and the passed config function.</p>","body":"<p>When using this convinience function a new index will be created with the<br />following functions already in the pipeline:</p>\n\n<p>lunr.StopWordFilter - filters out any stop words before they enter the<br />index</p>\n\n<p>lunr.stemmer - stems the tokens before entering the index.</p>\n\n<p>Example:</p>\n\n<pre><code>var idx = lunr(function () {\n  this.field('title', 10)\n  this.field('tags', 100)\n  this.field('body')\n\n  this.ref('cid')\n\n  this.pipeline.add(function () {\n    // some custome pipeline function\n  })\n\n})\n</code></pre>"},"full_description":"<p>Convinience function for instantiating a new lunr index and configuring it with the default pipeline functions and the passed config function.</p>\n\n<p>When using this convinience function a new index will be created with the following functions already in the pipeline:</p>\n\n<p>lunr.StopWordFilter - filters out any stop words before they enter the index</p>\n\n<p>lunr.stemmer - stems the tokens before entering the index.</p>\n\n<p>Example:</p>\n\n<pre><code>var idx = lunr(function () {\n  this.field('title', 10)\n  this.field('tags', 100)\n  this.field('body')\n\n  this.ref('cid')\n\n  this.pipeline.add(function () {\n    // some custome pipeline function\n  })\n\n})\n</code></pre>","code":"var lunr = function (config) {\n  var idx = new lunr.Index\n\n  idx.pipeline.add(lunr.stopWordFilter, lunr.stemmer)\n\n  if (config) config.call(idx, idx)\n\n  return idx\n}\n\nlunr.version = \"0.2.0\"","params":[{"type":"param","types":["Function"],"name":"config","description":"A function that will be called with the new instance"}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"config","description":"A function that will be called with the new instance"},{"type":"of","string":"the lunr.Index as both its context and first parameter. It can be used to"},{"type":"customize","string":"the instance of new lunr.Index."},{"type":"namespace","string":""},{"type":"module","string":""},{"type":"returns","string":"{lunr.Index}"}],"module":true,"related":{"href":""},"has_related":true,"methods":[]},{"id":"1-1361873428989","name":"tokenizer","signiture":"lunr.tokenizer()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"tokenizer","string":"lunr.tokenizer()"},"description":{"full":"<p>A function for splitting a string into tokens ready to be insterted into<br />the search index.</p>","summary":"<p>A function for splitting a string into tokens ready to be insterted into<br />the search index.</p>","body":""},"full_description":"<p>A function for splitting a string into tokens ready to be insterted into the search index.</p>","code":"lunr.tokenizer = function (str) {\n  if (Array.isArray(str)) return str\n\n  var trailingPunctuationRegex = /[\\!|\\,|\\.|\\?]+$/,\n      whiteSpaceSplitRegex = /\\s+/\n\n  return str.split(whiteSpaceSplitRegex).map(function (token) {\n    return token.replace(/^\\W+/, '').replace(/\\W+$/, '').toLowerCase()\n  })\n}","params":[{"type":"param","types":["String"],"name":"str","description":"The string to convert into tokens"}],"has_params":true,"tags":[{"type":"module","string":""},{"type":"param","types":["String"],"name":"str","description":"The string to convert into tokens"},{"type":"returns","string":"{Array}"}],"module":true,"related":{"href":""},"has_related":true,"methods":[]},{"id":"2-1361873428989","name":"Pipeline","signiture":"lunr.Pipeline()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"Pipeline","string":"lunr.Pipeline()"},"description":{"full":"<p>lunr.Pipelines maintain an ordered list of functions to be applied to all<br />tokens in documents entering the search index and queries being ran against<br />the index.</p>\n\n<p>An instance of lunr.Index created with the lunr shortcut will contain a<br />pipeline with a stop word filter and an English language stemmer. Extra<br />functions can be added before or after either of these functions or these<br />default functions can be removed.</p>\n\n<p>When run the pipeline will call each function in turn, passing a token, the<br />index of that token in the original list of all tokens and finally a list of<br />all the original tokens.</p>\n\n<p>The output of functions in the pipeline will be passed to the next function<br />in the pipeline. To exclude a token from entering the index the function<br />should return undefined, the rest of the pipeline will not be called with<br />this token.</p>","summary":"<p>lunr.Pipelines maintain an ordered list of functions to be applied to all<br />tokens in documents entering the search index and queries being ran against<br />the index.</p>","body":"<p>An instance of lunr.Index created with the lunr shortcut will contain a<br />pipeline with a stop word filter and an English language stemmer. Extra<br />functions can be added before or after either of these functions or these<br />default functions can be removed.</p>\n\n<p>When run the pipeline will call each function in turn, passing a token, the<br />index of that token in the original list of all tokens and finally a list of<br />all the original tokens.</p>\n\n<p>The output of functions in the pipeline will be passed to the next function<br />in the pipeline. To exclude a token from entering the index the function<br />should return undefined, the rest of the pipeline will not be called with<br />this token.</p>"},"full_description":"<p>lunr.Pipelines maintain an ordered list of functions to be applied to all tokens in documents entering the search index and queries being ran against the index.</p>\n\n<p>An instance of lunr.Index created with the lunr shortcut will contain a pipeline with a stop word filter and an English language stemmer. Extra functions can be added before or after either of these functions or these default functions can be removed.</p>\n\n<p>When run the pipeline will call each function in turn, passing a token, the index of that token in the original list of all tokens and finally a list of all the original tokens.</p>\n\n<p>The output of functions in the pipeline will be passed to the next function in the pipeline. To exclude a token from entering the index the function should return undefined, the rest of the pipeline will not be called with this token.</p>","code":"lunr.Pipeline = function () {\n  this._stack = []\n}","params":[],"has_params":false,"tags":[{"type":"constructor","string":""}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"3-1361873428989","name":"add","signiture":"lunr.Pipeline.prototype.add()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline.prototype","name":"add","string":"lunr.Pipeline.prototype.add()"},"description":{"full":"<p>Adds new functions to the end of the pipeline.</p>","summary":"<p>Adds new functions to the end of the pipeline.</p>","body":""},"full_description":"<p>Adds new functions to the end of the pipeline.</p>","code":"lunr.Pipeline.prototype.add = function () {\n  var fns = Array.prototype.slice.call(arguments)\n  Array.prototype.push.apply(this._stack, fns)\n}","params":[{"type":"param","types":["Function"],"name":"functions","description":"Any number of functions to add to the pipeline."}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"functions","description":"Any number of functions to add to the pipeline."},{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true},{"id":"4-1361873428989","name":"after","signiture":"lunr.Pipeline.prototype.after()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline.prototype","name":"after","string":"lunr.Pipeline.prototype.after()"},"description":{"full":"<p>Adds a single function after a function that already exists in the<br />pipeline.</p>","summary":"<p>Adds a single function after a function that already exists in the<br />pipeline.</p>","body":""},"full_description":"<p>Adds a single function after a function that already exists in the pipeline.</p>","code":"lunr.Pipeline.prototype.after = function (existingFn, newFn) {\n  var pos = this._stack.indexOf(existingFn) + 1\n  this._stack.splice(pos, 0, newFn)\n}","params":[{"type":"param","types":["Function"],"name":"existingFn","description":"A function that already exists in the pipeline."},{"type":"param","types":["Function"],"name":"newFn","description":"The new function to add to the pipeline."}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"existingFn","description":"A function that already exists in the pipeline."},{"type":"param","types":["Function"],"name":"newFn","description":"The new function to add to the pipeline."},{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true},{"id":"5-1361873428989","name":"before","signiture":"lunr.Pipeline.prototype.before()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline.prototype","name":"before","string":"lunr.Pipeline.prototype.before()"},"description":{"full":"<p>Adds a single function before a function that already exists in the<br />pipeline.</p>","summary":"<p>Adds a single function before a function that already exists in the<br />pipeline.</p>","body":""},"full_description":"<p>Adds a single function before a function that already exists in the pipeline.</p>","code":"lunr.Pipeline.prototype.before = function (existingFn, newFn) {\n  var pos = this._stack.indexOf(existingFn)\n  this._stack.splice(pos, 0, newFn)\n}","params":[{"type":"param","types":["Function"],"name":"existingFn","description":"A function that already exists in the pipeline."},{"type":"param","types":["Function"],"name":"newFn","description":"The new function to add to the pipeline."}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"existingFn","description":"A function that already exists in the pipeline."},{"type":"param","types":["Function"],"name":"newFn","description":"The new function to add to the pipeline."},{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true},{"id":"6-1361873428989","name":"remove","signiture":"lunr.Pipeline.prototype.remove()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline.prototype","name":"remove","string":"lunr.Pipeline.prototype.remove()"},"description":{"full":"<p>Removes a function from the pipeline.</p>","summary":"<p>Removes a function from the pipeline.</p>","body":""},"full_description":"<p>Removes a function from the pipeline.</p>","code":"lunr.Pipeline.prototype.remove = function (fn) {\n  var pos = this._stack.indexOf(fn)\n  this._stack.splice(pos, 1)\n}","params":[{"type":"param","types":["Function"],"name":"fn","description":"The function to remove from the pipeline."}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"fn","description":"The function to remove from the pipeline."},{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true},{"id":"7-1361873428989","name":"run","signiture":"lunr.Pipeline.prototype.run()","type":"method","ctx":{"type":"method","receiver":"lunr.Pipeline.prototype","name":"run","string":"lunr.Pipeline.prototype.run()"},"description":{"full":"<p>Runs the current list of functions that make up the pipeline against the<br />passed tokens.</p>","summary":"<p>Runs the current list of functions that make up the pipeline against the<br />passed tokens.</p>","body":""},"full_description":"<p>Runs the current list of functions that make up the pipeline against the passed tokens.</p>","code":"lunr.Pipeline.prototype.run = function (tokens) {\n  var out = [],\n      tokenLength = tokens.length,\n      stackLength = this._stack.length\n\n  for (var i = 0; i < tokenLength; i++) {\n    var token = tokens[i]\n\n    for (var j = 0; j < stackLength; j++) {\n      token = this._stack[j](token, i, tokens)\n      if (token === void 0) break\n    };\n\n    if (token !== void 0) out.push(token)\n  };\n\n  return out\n}","params":[{"type":"param","types":["Array"],"name":"tokens","description":"The tokens to run through the pipeline."}],"has_params":true,"tags":[{"type":"param","types":["Array"],"name":"tokens","description":"The tokens to run through the pipeline."},{"type":"returns","string":"{Array}"},{"type":"memberOf","parent":"Pipeline"}],"module":false,"parent":"Pipeline","related":{"href":""},"has_related":true}]},{"id":"8-1361873428989","name":"Vector","signiture":"lunr.Vector()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"Vector","string":"lunr.Vector()"},"description":{"full":"<p>lunr.Vectors wrap arrays and add vector related operations for the array<br />elements.</p>","summary":"<p>lunr.Vectors wrap arrays and add vector related operations for the array<br />elements.</p>","body":""},"full_description":"<p>lunr.Vectors wrap arrays and add vector related operations for the array elements.</p>","code":"lunr.Vector = function (elements) {\n  this.elements = elements\n\n  for (var i = 0; i < elements.length; i++) {\n    if (!(i in this.elements)) this.elements[i] = 0\n  }\n}","params":[{"type":"param","types":["Array"],"name":"elements","description":"Elements that make up the vector."}],"has_params":true,"tags":[{"type":"constructor","string":""},{"type":"param","types":["Array"],"name":"elements","description":"Elements that make up the vector."}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"9-1361873428989","name":"magnitude","signiture":"lunr.Vector.prototype.magnitude()","type":"method","ctx":{"type":"method","receiver":"lunr.Vector.prototype","name":"magnitude","string":"lunr.Vector.prototype.magnitude()"},"description":{"full":"<p>Calculates the magnitude of this vector.</p>","summary":"<p>Calculates the magnitude of this vector.</p>","body":""},"full_description":"<p>Calculates the magnitude of this vector.</p>","code":"lunr.Vector.prototype.magnitude = function () {\n  if (this._magnitude) return this._magnitude\n\n  var sumOfSquares = 0,\n      elems = this.elements,\n      len = elems.length,\n      magnitude, el\n\n  for (var i = 0; i < len; i++) {\n    el = elems[i]\n    sumOfSquares += el * el\n  };\n\n  return this._magnitude = Math.sqrt(sumOfSquares)\n}","params":[],"has_params":false,"tags":[{"type":"returns","string":"{Number}"},{"type":"memberOf","parent":"Vector"}],"module":false,"parent":"Vector","related":{"href":""},"has_related":true},{"id":"10-1361873428989","name":"dot","signiture":"lunr.Vector.prototype.dot()","type":"method","ctx":{"type":"method","receiver":"lunr.Vector.prototype","name":"dot","string":"lunr.Vector.prototype.dot()"},"description":{"full":"<p>Calculates the dot product of this vector and another vector.</p>","summary":"<p>Calculates the dot product of this vector and another vector.</p>","body":""},"full_description":"<p>Calculates the dot product of this vector and another vector.</p>","code":"lunr.Vector.prototype.dot = function (otherVector) {\n  var elem1 = this.elements,\n      elem2 = otherVector.elements,\n      length = elem1.length,\n      dotProduct = 0\n\n  for (var i = 0; i < length; i++) {\n    dotProduct += elem1[i] * elem2[i]\n  };\n\n  return dotProduct\n}","params":[{"type":"param","types":["lunr.Vector"],"name":"otherVector","description":"The vector to compute the dot product with."}],"has_params":true,"tags":[{"type":"param","types":["lunr.Vector"],"name":"otherVector","description":"The vector to compute the dot product with."},{"type":"returns","string":"{Number}"},{"type":"memberOf","parent":"Vector"}],"module":false,"parent":"Vector","related":{"href":""},"has_related":true},{"id":"11-1361873428989","name":"similarity","signiture":"lunr.Vector.prototype.similarity()","type":"method","ctx":{"type":"method","receiver":"lunr.Vector.prototype","name":"similarity","string":"lunr.Vector.prototype.similarity()"},"description":{"full":"<p>Calculates the cosine similarity between this vector and another<br />vector.</p>","summary":"<p>Calculates the cosine similarity between this vector and another<br />vector.</p>","body":""},"full_description":"<p>Calculates the cosine similarity between this vector and another vector.</p>","code":"lunr.Vector.prototype.similarity = function (otherVector) {\n  return this.dot(otherVector) / (this.magnitude() * otherVector.magnitude())\n}","params":[{"type":"param","types":["lunr.Vector"],"name":"otherVector","description":"The other vector to calculate the"}],"has_params":true,"tags":[{"type":"param","types":["lunr.Vector"],"name":"otherVector","description":"The other vector to calculate the"},{"type":"similarity","string":"with."},{"type":"returns","string":"{Number}"},{"type":"memberOf","parent":"Vector"}],"module":false,"parent":"Vector","related":{"href":""},"has_related":true},{"id":"12-1361873428989","name":"toArray","signiture":"lunr.Vector.prototype.toArray()","type":"method","ctx":{"type":"method","receiver":"lunr.Vector.prototype","name":"toArray","string":"lunr.Vector.prototype.toArray()"},"description":{"full":"<p>Converts this vector back into an array.</p>","summary":"<p>Converts this vector back into an array.</p>","body":""},"full_description":"<p>Converts this vector back into an array.</p>","code":"lunr.Vector.prototype.toArray = function () {\n  return this.elements\n}","params":[],"has_params":false,"tags":[{"type":"returns","string":"{Array}"},{"type":"memberOf","parent":"Vector"}],"module":false,"parent":"Vector","related":{"href":""},"has_related":true}]},{"id":"13-1361873428989","name":"SortedSet","signiture":"lunr.SortedSet()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"SortedSet","string":"lunr.SortedSet()"},"description":{"full":"<p>lunr.SortedSets are used to maintain an array of uniq values in a sorted<br />order.</p>","summary":"<p>lunr.SortedSets are used to maintain an array of uniq values in a sorted<br />order.</p>","body":""},"full_description":"<p>lunr.SortedSets are used to maintain an array of uniq values in a sorted order.</p>","code":"lunr.SortedSet = function () {\n  this.length = 0\n  this.elements = []\n}","params":[],"has_params":false,"tags":[{"type":"constructor","string":""}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"14-1361873428989","name":"add","signiture":"lunr.SortedSet.prototype.add()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"add","string":"lunr.SortedSet.prototype.add()"},"description":{"full":"<p>Inserts new items into the set in the correct position to maintain the<br />order.</p>","summary":"<p>Inserts new items into the set in the correct position to maintain the<br />order.</p>","body":""},"full_description":"<p>Inserts new items into the set in the correct position to maintain the order.</p>","code":"lunr.SortedSet.prototype.add = function () {\n  Array.prototype.slice.call(arguments).forEach(function (element) {\n    if (~this.elements.indexOf(element)) return\n    this.elements.splice(this.locationFor(element), 0, element)\n  }, this)\n\n  this.length = this.elements.length\n}","params":[{"type":"param","types":["Object"],"name":"The","description":"objects to add to this set."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"The","description":"objects to add to this set."},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"15-1361873428989","name":"toArray","signiture":"lunr.SortedSet.prototype.toArray()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"toArray","string":"lunr.SortedSet.prototype.toArray()"},"description":{"full":"<p>Converts this sorted set into an array.</p>","summary":"<p>Converts this sorted set into an array.</p>","body":""},"full_description":"<p>Converts this sorted set into an array.</p>","code":"lunr.SortedSet.prototype.toArray = function () {\n  return this.elements.slice()\n}","params":[],"has_params":false,"tags":[{"type":"returns","string":"{Array}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"16-1361873428989","name":"map","signiture":"lunr.SortedSet.prototype.map()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"map","string":"lunr.SortedSet.prototype.map()"},"description":{"full":"<p>Creates a new array with the results of calling a provided function on every<br />element in this sorted set.</p>\n\n<p>Delegates to Array.prototype.map and has the same signature.</p>","summary":"<p>Creates a new array with the results of calling a provided function on every<br />element in this sorted set.</p>","body":"<p>Delegates to Array.prototype.map and has the same signature.</p>"},"full_description":"<p>Creates a new array with the results of calling a provided function on every element in this sorted set.</p>\n\n<p>Delegates to Array.prototype.map and has the same signature.</p>","code":"lunr.SortedSet.prototype.map = function (fn, ctx) {\n  return this.elements.map(fn, ctx)\n}","params":[{"type":"param","types":["Function"],"name":"fn","description":"The function that is called on each element of the"},{"type":"param","types":["Object"],"name":"ctx","description":"An optional object that can be used as the context"}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"fn","description":"The function that is called on each element of the"},{"type":"set.","string":""},{"type":"param","types":["Object"],"name":"ctx","description":"An optional object that can be used as the context"},{"type":"for","string":"the function fn."},{"type":"returns","string":"{Array}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"17-1361873428989","name":"forEach","signiture":"lunr.SortedSet.prototype.forEach()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"forEach","string":"lunr.SortedSet.prototype.forEach()"},"description":{"full":"<p>Executes a provided function once per sorted set element.</p>\n\n<p>Delegates to Array.prototype.forEach and has the same signature.</p>","summary":"<p>Executes a provided function once per sorted set element.</p>","body":"<p>Delegates to Array.prototype.forEach and has the same signature.</p>"},"full_description":"<p>Executes a provided function once per sorted set element.</p>\n\n<p>Delegates to Array.prototype.forEach and has the same signature.</p>","code":"lunr.SortedSet.prototype.forEach = function (fn, ctx) {\n  return this.elements.forEach(fn, ctx)\n}","params":[{"type":"param","types":["Function"],"name":"fn","description":"The function that is called on each element of the"},{"type":"param","types":["Object"],"name":"ctx","description":"An optional object that can be used as the context"}],"has_params":true,"tags":[{"type":"param","types":["Function"],"name":"fn","description":"The function that is called on each element of the"},{"type":"set.","string":""},{"type":"param","types":["Object"],"name":"ctx","description":"An optional object that can be used as the context"},{"type":"memberOf","parent":"SortedSet"},{"type":"for","string":"the function fn."}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"18-1361873428989","name":"indexOf","signiture":"lunr.SortedSet.prototype.indexOf()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"indexOf","string":"lunr.SortedSet.prototype.indexOf()"},"description":{"full":"<p>Returns the first index at which a given element can be found in the<br />sorted set, or -1 if it is not present.</p>\n\n<p>Delegates to Array.prototype.indexOf and has the same signature.</p>","summary":"<p>Returns the first index at which a given element can be found in the<br />sorted set, or -1 if it is not present.</p>","body":"<p>Delegates to Array.prototype.indexOf and has the same signature.</p>"},"full_description":"<p>Returns the first index at which a given element can be found in the sorted set, or -1 if it is not present.</p>\n\n<p>Delegates to Array.prototype.indexOf and has the same signature.</p>","code":"lunr.SortedSet.prototype.indexOf = function (elem, startIndex) {\n  return this.elements.indexOf(elem)\n}","params":[{"type":"param","types":["Object"],"name":"elem","description":"The object to locate in the sorted set."},{"type":"param","types":["Number"],"name":"startIndex","description":"The index at which to begin the search."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"elem","description":"The object to locate in the sorted set."},{"type":"param","types":["Number"],"name":"startIndex","description":"The index at which to begin the search."},{"type":"returns","string":"{Number}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"19-1361873428989","name":"locationFor","signiture":"lunr.SortedSet.prototype.locationFor()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"locationFor","string":"lunr.SortedSet.prototype.locationFor()"},"description":{"full":"<p>Returns the position within the sorted set that an element should be<br />inserted at to maintain the current order of the set.</p>\n\n<p>This function assumes that the element to search for does not already exist<br />in the sorted set.</p>","summary":"<p>Returns the position within the sorted set that an element should be<br />inserted at to maintain the current order of the set.</p>","body":"<p>This function assumes that the element to search for does not already exist<br />in the sorted set.</p>"},"full_description":"<p>Returns the position within the sorted set that an element should be inserted at to maintain the current order of the set.</p>\n\n<p>This function assumes that the element to search for does not already exist in the sorted set.</p>","code":"lunr.SortedSet.prototype.locationFor = function (elem, start, end) {\n  var start = start || 0,\n      end = end || this.elements.length,\n      sectionLength = end - start,\n      pivot = start + Math.floor(sectionLength / 2),\n      pivotElem = this.elements[pivot]\n\n  if (sectionLength <= 1) {\n    if (pivotElem > elem) return pivot\n    if (pivotElem < elem) return pivot + 1\n  }\n\n  if (pivotElem < elem) return this.locationFor(elem, pivot, end)\n  if (pivotElem > elem) return this.locationFor(elem, start, pivot)\n}","params":[{"type":"param","types":["Object"],"name":"elem","description":"The elem to find the position for in the set"},{"type":"param","types":["Number"],"name":"start","description":"An optional index at which to start searching from"},{"type":"param","types":["Number"],"name":"end","description":"An optional index at which to stop search from within"}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"elem","description":"The elem to find the position for in the set"},{"type":"param","types":["Number"],"name":"start","description":"An optional index at which to start searching from"},{"type":"within","string":"the set."},{"type":"param","types":["Number"],"name":"end","description":"An optional index at which to stop search from within"},{"type":"the","string":"set."},{"type":"returns","string":"{Number}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"20-1361873428989","name":"intersect","signiture":"lunr.SortedSet.prototype.intersect()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"intersect","string":"lunr.SortedSet.prototype.intersect()"},"description":{"full":"<p>Creates a new lunr.SortedSet that contains the elements in the intersection<br />of this set and the passed set.</p>","summary":"<p>Creates a new lunr.SortedSet that contains the elements in the intersection<br />of this set and the passed set.</p>","body":""},"full_description":"<p>Creates a new lunr.SortedSet that contains the elements in the intersection of this set and the passed set.</p>","code":"lunr.SortedSet.prototype.intersect = function (otherSet) {\n  var intersectSet = new lunr.SortedSet,\n      i = 0, j = 0,\n      a_len = this.length, b_len = otherSet.length,\n      a = this.elements, b = otherSet.elements\n\n  while (true) {\n    if (i > a_len - 1 || j > b_len - 1) break\n\n    if (a[i] === b[j]) {\n      intersectSet.add(a[i])\n      i++, j++\n      continue\n    }\n\n    if (a[i] < b[j]) {\n      i++\n      continue\n    }\n\n    if (a[i] > b[j]) {\n      j++\n      continue\n    }\n  };\n\n  return intersectSet\n}","params":[{"type":"param","types":["lunr.SortedSet"],"name":"otherSet","description":"The set to intersect with this set."}],"has_params":true,"tags":[{"type":"param","types":["lunr.SortedSet"],"name":"otherSet","description":"The set to intersect with this set."},{"type":"returns","string":"{lunr.SortedSet}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"21-1361873428989","name":"clone","signiture":"lunr.SortedSet.prototype.clone()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"clone","string":"lunr.SortedSet.prototype.clone()"},"description":{"full":"<p>Makes a copy of this set</p>","summary":"<p>Makes a copy of this set</p>","body":""},"full_description":"<p>Makes a copy of this set</p>","code":"lunr.SortedSet.prototype.clone = function () {\n  var clone = new lunr.SortedSet\n\n  clone.elements = this.toArray()\n  clone.length = clone.elements.length\n\n  return clone\n}","params":[],"has_params":false,"tags":[{"type":"returns","string":"{lunr.SortedSet}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true},{"id":"22-1361873428989","name":"union","signiture":"lunr.SortedSet.prototype.union()","type":"method","ctx":{"type":"method","receiver":"lunr.SortedSet.prototype","name":"union","string":"lunr.SortedSet.prototype.union()"},"description":{"full":"<p>Creates a new lunr.SortedSet that contains the elements in the union<br />of this set and the passed set.</p>","summary":"<p>Creates a new lunr.SortedSet that contains the elements in the union<br />of this set and the passed set.</p>","body":""},"full_description":"<p>Creates a new lunr.SortedSet that contains the elements in the union of this set and the passed set.</p>","code":"lunr.SortedSet.prototype.union = function (otherSet) {\n  var longSet, shortSet, unionSet\n\n  if (this.length >= otherSet.length) {\n    longSet = this, shortSet = otherSet\n  } else {\n    longSet = otherSet, shortSet = this\n  }\n\n  unionSet = longSet.clone()\n\n  unionSet.add.apply(unionSet, shortSet.toArray())\n\n  return unionSet\n}","params":[{"type":"param","types":["lunr.SortedSet"],"name":"otherSet","description":"The set to union with this set."}],"has_params":true,"tags":[{"type":"param","types":["lunr.SortedSet"],"name":"otherSet","description":"The set to union with this set."},{"type":"returns","string":"{lunr.SortedSet}"},{"type":"memberOf","parent":"SortedSet"}],"module":false,"parent":"SortedSet","related":{"href":""},"has_related":true}]},{"id":"23-1361873428989","name":"Index","signiture":"lunr.Index()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"Index","string":"lunr.Index()"},"description":{"full":"<p>lunr.Index is object that manages a search index.  It contains the indexes<br />and stores all the tokens and document lookups.  It also provides the main<br />user facing API for the library.</p>","summary":"<p>lunr.Index is object that manages a search index.  It contains the indexes<br />and stores all the tokens and document lookups.  It also provides the main<br />user facing API for the library.</p>","body":""},"full_description":"<p>lunr.Index is object that manages a search index.  It contains the indexes and stores all the tokens and document lookups.  It also provides the main user facing API for the library.</p>","code":"lunr.Index = function () {\n  this._fields = []\n  this._ref = 'id'\n  this.pipeline = new lunr.Pipeline\n  this.documentStore = new lunr.Store\n  this.tokenStore = new lunr.TokenStore\n  this.corpusTokens = new lunr.SortedSet\n}","params":[],"has_params":false,"tags":[{"type":"constructor","string":""}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"24-1361873428989","name":"field","signiture":"lunr.Index.prototype.field()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"field","string":"lunr.Index.prototype.field()"},"description":{"full":"<p>Adds a field to the list of fields that will be searchable within documents<br />in the index.</p>\n\n<p>An optional boost param can be passed to affect how much tokens in this field<br />rank in search results, by default the boost value is 1.</p>\n\n<p>Fields should be added before any documents are added to the index, fields<br />that are added after documents are added to the index will only apply to new<br />documents added to the index.</p>","summary":"<p>Adds a field to the list of fields that will be searchable within documents<br />in the index.</p>","body":"<p>An optional boost param can be passed to affect how much tokens in this field<br />rank in search results, by default the boost value is 1.</p>\n\n<p>Fields should be added before any documents are added to the index, fields<br />that are added after documents are added to the index will only apply to new<br />documents added to the index.</p>"},"full_description":"<p>Adds a field to the list of fields that will be searchable within documents in the index.</p>\n\n<p>An optional boost param can be passed to affect how much tokens in this field rank in search results, by default the boost value is 1.</p>\n\n<p>Fields should be added before any documents are added to the index, fields that are added after documents are added to the index will only apply to new documents added to the index.</p>","code":"lunr.Index.prototype.field = function (fieldName, opts) {\n  var opts = opts || {},\n      field = { name: fieldName, boost: opts.boost || 1 }\n\n  this._fields.push(field)\n  return this\n}","params":[{"type":"param","types":["String"],"name":"fieldName","description":"The name of the field within the document that"},{"type":"param","types":["Number"],"name":"boost","description":"An optional boost that can be applied to terms in this"}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"fieldName","description":"The name of the field within the document that"},{"type":"should","string":"be indexed"},{"type":"param","types":["Number"],"name":"boost","description":"An optional boost that can be applied to terms in this"},{"type":"field.","string":""},{"type":"returns","string":"{lunr.Index}"},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"25-1361873428989","name":"ref","signiture":"lunr.Index.prototype.ref()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"ref","string":"lunr.Index.prototype.ref()"},"description":{"full":"<p>Sets the property used to uniquely indetify documents added to the index,<br />by default this property is 'id'.</p>\n\n<p>This should only be changed before adding documents to the index, changing<br />the ref property without resetting the index can lead to unexpected results.</p>","summary":"<p>Sets the property used to uniquely indetify documents added to the index,<br />by default this property is 'id'.</p>","body":"<p>This should only be changed before adding documents to the index, changing<br />the ref property without resetting the index can lead to unexpected results.</p>"},"full_description":"<p>Sets the property used to uniquely indetify documents added to the index, by default this property is 'id'.</p>\n\n<p>This should only be changed before adding documents to the index, changing the ref property without resetting the index can lead to unexpected results.</p>","code":"lunr.Index.prototype.ref = function (refName) {\n  this._ref = refName\n  return this\n}","params":[{"type":"param","types":["String"],"name":"refName","description":"The property to use to uniquely identify the"}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"refName","description":"The property to use to uniquely identify the"},{"type":"documents","string":"in the index."},{"type":"returns","string":"{lunr.Index}"},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"26-1361873428989","name":"add","signiture":"lunr.Index.prototype.add()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"add","string":"lunr.Index.prototype.add()"},"description":{"full":"<p>Add a document to the index.</p>\n\n<p>This is the way new documents enter the index, this function will run the<br />fields from the document through the index's pipeline and then add it to<br />the index, it will then show up in search results.</p>","summary":"<p>Add a document to the index.</p>","body":"<p>This is the way new documents enter the index, this function will run the<br />fields from the document through the index's pipeline and then add it to<br />the index, it will then show up in search results.</p>"},"full_description":"<p>Add a document to the index.</p>\n\n<p>This is the way new documents enter the index, this function will run the fields from the document through the index's pipeline and then add it to the index, it will then show up in search results.</p>","code":"lunr.Index.prototype.add = function (doc) {\n  var docTokens = {},\n      allDocumentTokens = new lunr.SortedSet,\n      docRef = doc[this._ref]\n\n  this._fields.forEach(function (field) {\n    var fieldTokens = this.pipeline.run(lunr.tokenizer(doc[field.name]))\n\n    docTokens[field.name] = fieldTokens\n    lunr.SortedSet.prototype.add.apply(allDocumentTokens, fieldTokens)\n  }, this)\n\n  this.documentStore.set(docRef, allDocumentTokens)\n  lunr.SortedSet.prototype.add.apply(this.corpusTokens, allDocumentTokens.toArray())\n\n  for (var i = 0; i < allDocumentTokens.length; i++) {\n    var token = allDocumentTokens.elements[i]\n    var tf = this._fields.reduce(function (memo, field) {\n      var tokenCount = docTokens[field.name].filter(function (t) { return t === token }).length,\n          fieldLength = docTokens[field.name].length\n\n      return memo + (tokenCount / fieldLength * field.boost)\n    }, 0)\n\n    this.tokenStore.add(token, { ref: docRef, tf: tf })\n  };\n}","params":[{"type":"param","types":["Object"],"name":"doc","description":"The document to add to the index."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"doc","description":"The document to add to the index."},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"27-1361873428989","name":"remove","signiture":"lunr.Index.prototype.remove()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"remove","string":"lunr.Index.prototype.remove()"},"description":{"full":"<p>Removes a document from the index.</p>\n\n<p>To make sure documents no longer show up in search results they can be<br />removed from the index using this method.</p>\n\n<p>The document passed only needs to have the same ref property value as the<br />document that was added to the index, they could be completly different<br />objects.</p>","summary":"<p>Removes a document from the index.</p>","body":"<p>To make sure documents no longer show up in search results they can be<br />removed from the index using this method.</p>\n\n<p>The document passed only needs to have the same ref property value as the<br />document that was added to the index, they could be completly different<br />objects.</p>"},"full_description":"<p>Removes a document from the index.</p>\n\n<p>To make sure documents no longer show up in search results they can be removed from the index using this method.</p>\n\n<p>The document passed only needs to have the same ref property value as the document that was added to the index, they could be completly different objects.</p>","code":"lunr.Index.prototype.remove = function (doc) {\n  var docRef = doc[this._ref],\n      docTokens = this.documentStore.get(docRef)\n\n  this.documentStore.remove(docRef)\n\n  docTokens.forEach(function (token) {\n    this.tokenStore.remove(token, docRef)\n  }, this)\n}","params":[{"type":"param","types":["Object"],"name":"doc","description":"The document to remove from the index."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"doc","description":"The document to remove from the index."},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"28-1361873428990","name":"update","signiture":"lunr.Index.prototype.update()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"update","string":"lunr.Index.prototype.update()"},"description":{"full":"<p>Updates a document in the index.</p>\n\n<p>When a document contained within the index gets updated, fields changed,<br />added or removed, to make sure it correctly matched against search queries,<br />it should be updated in the index.</p>\n\n<p>This method is just a wrapper around <code>remove</code> and <code>add</code></p>","summary":"<p>Updates a document in the index.</p>","body":"<p>When a document contained within the index gets updated, fields changed,<br />added or removed, to make sure it correctly matched against search queries,<br />it should be updated in the index.</p>\n\n<p>This method is just a wrapper around <code>remove</code> and <code>add</code></p>"},"full_description":"<p>Updates a document in the index.</p>\n\n<p>When a document contained within the index gets updated, fields changed, added or removed, to make sure it correctly matched against search queries, it should be updated in the index.</p>\n\n<p>This method is just a wrapper around <code>remove</code> and <code>add</code></p>","code":"lunr.Index.prototype.update = function (doc) {\n  this.remove(doc)\n  this.add(doc)\n}","params":[{"type":"param","types":["Object"],"name":"doc","description":"The document to update in the index."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"doc","description":"The document to update in the index."},{"type":"see","local":"Index.prototype.remove","visibility":"Index.prototype.remove"},{"type":"see","local":"Index.prototype.add","visibility":"Index.prototype.add"},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"29-1361873428990","name":"idf","signiture":"lunr.Index.prototype.idf()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"idf","string":"lunr.Index.prototype.idf()"},"description":{"full":"<p>Calculates the inverse document frequency for a token within the index.</p>","summary":"<p>Calculates the inverse document frequency for a token within the index.</p>","body":""},"full_description":"<p>Calculates the inverse document frequency for a token within the index.</p>","code":"lunr.Index.prototype.idf = function (term) {\n  var documentFrequency = Object.keys(this.tokenStore.get(term)).length\n\n  if (documentFrequency === 0) {\n    return 1\n  } else {\n    return 1 + Math.log(this.tokenStore.length / documentFrequency)\n  }\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to calculate the idf of."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"token","description":"The token to calculate the idf of."},{"type":"see","local":"Index.prototype.idf","visibility":"Index.prototype.idf"},{"type":"private","string":""},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"30-1361873428990","name":"search","signiture":"lunr.Index.prototype.search()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"search","string":"lunr.Index.prototype.search()"},"description":{"full":"<p>Searches the index using the passed query.</p>\n\n<p>Queries should be a string, multiple words are allowed and will lead to an<br />AND based query, e.g. <code>idx.search('foo bar')</code> will run a search for<br />documents containing both 'foo' and 'bar'.</p>\n\n<p>All query tokens are passed through the same pipeline that document tokens<br />are passed through, so any lanugage processing involved will be run on every<br />query term.</p>\n\n<p>Each query term is expanded, so that the term 'he' might be expanded to<br />'hello' and 'help' if those terms were already included in the index.</p>\n\n<p>Matching documents are returned as an array of objects, each object contains<br />the matching document ref, as set for this index, and the similarity score<br />for this document against the query.</p>","summary":"<p>Searches the index using the passed query.</p>","body":"<p>Queries should be a string, multiple words are allowed and will lead to an<br />AND based query, e.g. <code>idx.search('foo bar')</code> will run a search for<br />documents containing both 'foo' and 'bar'.</p>\n\n<p>All query tokens are passed through the same pipeline that document tokens<br />are passed through, so any lanugage processing involved will be run on every<br />query term.</p>\n\n<p>Each query term is expanded, so that the term 'he' might be expanded to<br />'hello' and 'help' if those terms were already included in the index.</p>\n\n<p>Matching documents are returned as an array of objects, each object contains<br />the matching document ref, as set for this index, and the similarity score<br />for this document against the query.</p>"},"full_description":"<p>Searches the index using the passed query.</p>\n\n<p>Queries should be a string, multiple words are allowed and will lead to an AND based query, e.g. <code>idx.search('foo bar')</code> will run a search for documents containing both 'foo' and 'bar'.</p>\n\n<p>All query tokens are passed through the same pipeline that document tokens are passed through, so any lanugage processing involved will be run on every query term.</p>\n\n<p>Each query term is expanded, so that the term 'he' might be expanded to 'hello' and 'help' if those terms were already included in the index.</p>\n\n<p>Matching documents are returned as an array of objects, each object contains the matching document ref, as set for this index, and the similarity score for this document against the query.</p>","code":"lunr.Index.prototype.search = function (query) {\n  var queryTokens = this.pipeline.run(lunr.tokenizer(query)),\n      queryArr = new Array (this.corpusTokens.length),\n      documentSets = [],\n      fieldBoosts = this._fields.reduce(function (memo, f) { return memo + f.boost }, 0)\n\n  if (!queryTokens.some(lunr.TokenStore.prototype.has, this.tokenStore)) return []\n\n  queryTokens\n    .forEach(function (token, i, tokens) {\n      var tf = 1 / tokens.length * this._fields.length * fieldBoosts,\n          self = this\n\n      var set = this.tokenStore.expand(token).reduce(function (memo, key) {\n        var pos = self.corpusTokens.indexOf(key),\n            idf = self.idf(key),\n            set = new lunr.SortedSet\n\n        if (pos > -1) queryArr[pos] = tf * idf\n\n        Object.keys(self.tokenStore.get(key)).forEach(function (ref) { set.add(ref) })\n\n        return memo.union(set)\n      }, new lunr.SortedSet)\n\n      documentSets.push(set)\n    }, this)\n\n  var documentSet = documentSets.reduce(function (memo, set) {\n    return memo.intersect(set)\n  })\n\n  var queryVector = new lunr.Vector (queryArr)\n\n  return documentSet\n    .map(function (ref) {\n      return { ref: ref, score: queryVector.similarity(this.documentVector(ref)) }\n    }, this)\n    .sort(function (a, b) {\n      return b.score - a.score\n    })\n}","params":[{"type":"param","types":["String"],"name":"query","description":"The query to search the index with."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"query","description":"The query to search the index with."},{"type":"returns","string":"{Object}"},{"type":"see","local":"Index.prototype.idf","visibility":"Index.prototype.idf"},{"type":"see","local":"Index.prototype.documentVector","visibility":"Index.prototype.documentVector"},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true},{"id":"31-1361873428990","name":"documentVector","signiture":"lunr.Index.prototype.documentVector()","type":"method","ctx":{"type":"method","receiver":"lunr.Index.prototype","name":"documentVector","string":"lunr.Index.prototype.documentVector()"},"description":{"full":"<p>Generates a vector containing all the tokens in the document matching the<br />passed documentRef.</p>\n\n<p>The vector contains the tf-idf score for each token contained in the<br />document with the passed documentRef.  The vector will contain an element<br />for every token in the indexes corpus, if the document does not contain that<br />token the element will be 0.</p>","summary":"<p>Generates a vector containing all the tokens in the document matching the<br />passed documentRef.</p>","body":"<p>The vector contains the tf-idf score for each token contained in the<br />document with the passed documentRef.  The vector will contain an element<br />for every token in the indexes corpus, if the document does not contain that<br />token the element will be 0.</p>"},"full_description":"<p>Generates a vector containing all the tokens in the document matching the passed documentRef.</p>\n\n<p>The vector contains the tf-idf score for each token contained in the document with the passed documentRef.  The vector will contain an element for every token in the indexes corpus, if the document does not contain that token the element will be 0.</p>","code":"lunr.Index.prototype.documentVector = function (documentRef) {\n  var documentTokens = this.documentStore.get(documentRef),\n      documentTokensLength = documentTokens.length,\n      documentArr = new Array (this.corpusTokens.length)\n\n  for (var i = 0; i < documentTokensLength; i++) {\n    var token = documentTokens.elements[i],\n        tf = this.tokenStore.get(token)[documentRef].tf,\n        idf = this.idf(token)\n\n    documentArr[this.corpusTokens.indexOf(token)] = tf * idf\n  };\n\n  return new lunr.Vector (documentArr)\n}","params":[{"type":"param","types":["Object"],"name":"documentRef","description":"The ref to find the document with."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"documentRef","description":"The ref to find the document with."},{"type":"returns","string":"{lunr.Vector}"},{"type":"private","string":""},{"type":"memberOf","parent":"Index"}],"module":false,"parent":"Index","related":{"href":""},"has_related":true}]},{"id":"32-1361873428990","name":"Store","signiture":"lunr.Store()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"Store","string":"lunr.Store()"},"description":{"full":"<p>lunr.Store is a simple key-value store used for storing sets of tokens for<br />documents stored in index.</p>","summary":"<p>lunr.Store is a simple key-value store used for storing sets of tokens for<br />documents stored in index.</p>","body":""},"full_description":"<p>lunr.Store is a simple key-value store used for storing sets of tokens for documents stored in index.</p>","code":"lunr.Store = function () {\n  this.store = {}\n  this.length = 0\n}","params":[],"has_params":false,"tags":[{"type":"constructor","string":""},{"type":"module","string":""}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"33-1361873428990","name":"set","signiture":"lunr.Store.prototype.set()","type":"method","ctx":{"type":"method","receiver":"lunr.Store.prototype","name":"set","string":"lunr.Store.prototype.set()"},"description":{"full":"<p>Stores the given tokens in the store against the given id.</p>","summary":"<p>Stores the given tokens in the store against the given id.</p>","body":""},"full_description":"<p>Stores the given tokens in the store against the given id.</p>","code":"lunr.Store.prototype.set = function (id, tokens) {\n  this.store[id] = tokens\n  this.length = Object.keys(this.store).length\n}","params":[{"type":"param","types":["Object"],"name":"id","description":"The key used to store the tokens against."},{"type":"param","types":["Object"],"name":"tokens","description":"The tokens to store against the key."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"id","description":"The key used to store the tokens against."},{"type":"param","types":["Object"],"name":"tokens","description":"The tokens to store against the key."},{"type":"memberOf","parent":"Store"}],"module":false,"parent":"Store","related":{"href":""},"has_related":true},{"id":"34-1361873428990","name":"get","signiture":"lunr.Store.prototype.get()","type":"method","ctx":{"type":"method","receiver":"lunr.Store.prototype","name":"get","string":"lunr.Store.prototype.get()"},"description":{"full":"<p>Retrieves the tokens from the store for a given key.</p>","summary":"<p>Retrieves the tokens from the store for a given key.</p>","body":""},"full_description":"<p>Retrieves the tokens from the store for a given key.</p>","code":"lunr.Store.prototype.get = function (id) {\n  return this.store[id]\n}","params":[{"type":"param","types":["Object"],"name":"id","description":"The key to lookup and retrieve from the store."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"id","description":"The key to lookup and retrieve from the store."},{"type":"returns","string":"{Object}"},{"type":"memberOf","parent":"Store"}],"module":false,"parent":"Store","related":{"href":""},"has_related":true},{"id":"35-1361873428990","name":"has","signiture":"lunr.Store.prototype.has()","type":"method","ctx":{"type":"method","receiver":"lunr.Store.prototype","name":"has","string":"lunr.Store.prototype.has()"},"description":{"full":"<p>Checks whether the store contains a key.</p>","summary":"<p>Checks whether the store contains a key.</p>","body":""},"full_description":"<p>Checks whether the store contains a key.</p>","code":"lunr.Store.prototype.has = function (id) {\n  return id in this.store\n}","params":[{"type":"param","types":["Object"],"name":"id","description":"The id to look up in the store."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"id","description":"The id to look up in the store."},{"type":"returns","string":"{Boolean}"},{"type":"memberOf","parent":"Store"}],"module":false,"parent":"Store","related":{"href":""},"has_related":true},{"id":"36-1361873428990","name":"remove","signiture":"lunr.Store.prototype.remove()","type":"method","ctx":{"type":"method","receiver":"lunr.Store.prototype","name":"remove","string":"lunr.Store.prototype.remove()"},"description":{"full":"<p>Removes the value for a key in the store.</p>","summary":"<p>Removes the value for a key in the store.</p>","body":""},"full_description":"<p>Removes the value for a key in the store.</p>","code":"lunr.Store.prototype.remove = function (id) {\n  if (!this.has(id)) return\n\n  delete this.store[id]\n  this.length--\n}","params":[{"type":"param","types":["Object"],"name":"id","description":"The id to remove from the store."}],"has_params":true,"tags":[{"type":"param","types":["Object"],"name":"id","description":"The id to remove from the store."},{"type":"memberOf","parent":"Store"}],"module":false,"parent":"Store","related":{"href":""},"has_related":true}]},{"id":"37-1361873428990","name":"stemmer","signiture":"lunr.stemmer","type":"property","ctx":{"type":"property","receiver":"lunr","name":"stemmer","value":"(function(){","string":"lunr.stemmer"},"description":{"full":"<p>lunr.stemmer is an english language stemmer, this is a JavaScript<br />implementation of the PorterStemmer taken from <a href='http://tartaurs.org/~martin'>http://tartaurs.org/~martin</a></p>","summary":"<p>lunr.stemmer is an english language stemmer, this is a JavaScript<br />implementation of the PorterStemmer taken from <a href='http://tartaurs.org/~martin'>http://tartaurs.org/~martin</a></p>","body":""},"full_description":"<p>lunr.stemmer is an english language stemmer, this is a JavaScript implementation of the PorterStemmer taken from <a href='http://tartaurs.org/~martin'>http://tartaurs.org/~martin</a></p>","code":"lunr.stemmer = (function(){\n  var step2list = {\n      \"ational\" : \"ate\",\n      \"tional\" : \"tion\",\n      \"enci\" : \"ence\",\n      \"anci\" : \"ance\",\n      \"izer\" : \"ize\",\n      \"bli\" : \"ble\",\n      \"alli\" : \"al\",\n      \"entli\" : \"ent\",\n      \"eli\" : \"e\",\n      \"ousli\" : \"ous\",\n      \"ization\" : \"ize\",\n      \"ation\" : \"ate\",\n      \"ator\" : \"ate\",\n      \"alism\" : \"al\",\n      \"iveness\" : \"ive\",\n      \"fulness\" : \"ful\",\n      \"ousness\" : \"ous\",\n      \"aliti\" : \"al\",\n      \"iviti\" : \"ive\",\n      \"biliti\" : \"ble\",\n      \"logi\" : \"log\"\n    },\n\n    step3list = {\n      \"icate\" : \"ic\",\n      \"ative\" : \"\",\n      \"alize\" : \"al\",\n      \"iciti\" : \"ic\",\n      \"ical\" : \"ic\",\n      \"ful\" : \"\",\n      \"ness\" : \"\"\n    },\n\n    c = \"[^aeiou]\",          // consonant\n    v = \"[aeiouy]\",          // vowel\n    C = c + \"[^aeiouy]*\",    // consonant sequence\n    V = v + \"[aeiou]*\",      // vowel sequence\n\n    mgr0 = \"^(\" + C + \")?\" + V + C,               // [C]VC... is m>0\n    meq1 = \"^(\" + C + \")?\" + V + C + \"(\" + V + \")?$\",  // [C]VC[V] is m=1\n    mgr1 = \"^(\" + C + \")?\" + V + C + V + C,       // [C]VCVC... is m>1\n    s_v = \"^(\" + C + \")?\" + v;                   // vowel in stem\n\n  return function (w) {\n    var   stem,\n      suffix,\n      firstch,\n      re,\n      re2,\n      re3,\n      re4,\n      origword = w;\n\n    if (w.length < 3) { return w; }\n\n    firstch = w.substr(0,1);\n    if (firstch == \"y\") {\n      w = firstch.toUpperCase() + w.substr(1);\n    }\n\n    // Step 1a\n    re = /^(.+?)(ss|i)es$/;\n    re2 = /^(.+?)([^s])s$/;\n\n    if (re.test(w)) { w = w.replace(re,\"$1$2\"); }\n    else if (re2.test(w)) { w = w.replace(re2,\"$1$2\"); }\n\n    // Step 1b\n    re = /^(.+?)eed$/;\n    re2 = /^(.+?)(ed|ing)$/;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      re = new RegExp(mgr0);\n      if (re.test(fp[1])) {\n        re = /.$/;\n        w = w.replace(re,\"\");\n      }\n    } else if (re2.test(w)) {\n      var fp = re2.exec(w);\n      stem = fp[1];\n      re2 = new RegExp(s_v);\n      if (re2.test(stem)) {\n        w = stem;\n        re2 = /(at|bl|iz)$/;\n        re3 = new RegExp(\"([^aeiouylsz])\\\\1$\");\n        re4 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n        if (re2.test(w)) {  w = w + \"e\"; }\n        else if (re3.test(w)) { re = /.$/; w = w.replace(re,\"\"); }\n        else if (re4.test(w)) { w = w + \"e\"; }\n      }\n    }\n\n    // Step 1c\n    re = /^(.+?)y$/;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      re = new RegExp(s_v);\n      if (re.test(stem)) { w = stem + \"i\"; }\n    }\n\n    // Step 2\n    re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      suffix = fp[2];\n      re = new RegExp(mgr0);\n      if (re.test(stem)) {\n        w = stem + step2list[suffix];\n      }\n    }\n\n    // Step 3\n    re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      suffix = fp[2];\n      re = new RegExp(mgr0);\n      if (re.test(stem)) {\n        w = stem + step3list[suffix];\n      }\n    }\n\n    // Step 4\n    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;\n    re2 = /^(.+?)(s|t)(ion)$/;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      re = new RegExp(mgr1);\n      if (re.test(stem)) {\n        w = stem;\n      }\n    } else if (re2.test(w)) {\n      var fp = re2.exec(w);\n      stem = fp[1] + fp[2];\n      re2 = new RegExp(mgr1);\n      if (re2.test(stem)) {\n        w = stem;\n      }\n    }\n\n    // Step 5\n    re = /^(.+?)e$/;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      re = new RegExp(mgr1);\n      re2 = new RegExp(meq1);\n      re3 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n      if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {\n        w = stem;\n      }\n    }\n\n    re = /ll$/;\n    re2 = new RegExp(mgr1);\n    if (re.test(w) && re2.test(w)) {\n      re = /.$/;\n      w = w.replace(re,\"\");\n    }\n\n    // and turn initial Y back to y\n\n    if (firstch == \"y\") {\n      w = firstch.toLowerCase() + w.substr(1);\n    }\n\n    return w;\n  }\n})();","params":[{"type":"param","types":["String"],"name":"str","description":"The string to stem"}],"has_params":true,"tags":[{"type":"module","string":""},{"type":"param","types":["String"],"name":"str","description":"The string to stem"},{"type":"returns","string":"{String}"},{"type":"see","local":"lunr.Pipeline","visibility":"lunr.Pipeline"}],"module":true,"related":{"href":""},"has_related":true,"methods":[]},{"id":"38-1361873428990","name":"stopWordFilter","signiture":"lunr.stopWordFilter()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"stopWordFilter","string":"lunr.stopWordFilter()"},"description":{"full":"<p>lunr.stopWordFilter is an English language stop word list filter, any words<br />contained in the list will not be passed through the filter.</p>\n\n<p>This is intented to be used in the Pipeline. If the token does not pass the<br />filter then undefined will be returned.</p>","summary":"<p>lunr.stopWordFilter is an English language stop word list filter, any words<br />contained in the list will not be passed through the filter.</p>","body":"<p>This is intented to be used in the Pipeline. If the token does not pass the<br />filter then undefined will be returned.</p>"},"full_description":"<p>lunr.stopWordFilter is an English language stop word list filter, any words contained in the list will not be passed through the filter.</p>\n\n<p>This is intented to be used in the Pipeline. If the token does not pass the filter then undefined will be returned.</p>","code":"lunr.stopWordFilter = function (token) {\n  var stopWords = [\n    \"a\",\n    \"able\",\n    \"about\",\n    \"across\",\n    \"after\",\n    \"all\",\n    \"almost\",\n    \"also\",\n    \"am\",\n    \"among\",\n    \"an\",\n    \"and\",\n    \"any\",\n    \"are\",\n    \"as\",\n    \"at\",\n    \"be\",\n    \"because\",\n    \"been\",\n    \"but\",\n    \"by\",\n    \"can\",\n    \"cannot\",\n    \"could\",\n    \"dear\",\n    \"did\",\n    \"do\",\n    \"does\",\n    \"either\",\n    \"else\",\n    \"ever\",\n    \"every\",\n    \"for\",\n    \"from\",\n    \"get\",\n    \"got\",\n    \"had\",\n    \"has\",\n    \"have\",\n    \"he\",\n    \"her\",\n    \"hers\",\n    \"him\",\n    \"his\",\n    \"how\",\n    \"however\",\n    \"i\",\n    \"if\",\n    \"in\",\n    \"into\",\n    \"is\",\n    \"it\",\n    \"its\",\n    \"just\",\n    \"least\",\n    \"let\",\n    \"like\",\n    \"likely\",\n    \"may\",\n    \"me\",\n    \"might\",\n    \"most\",\n    \"must\",\n    \"my\",\n    \"neither\",\n    \"no\",\n    \"nor\",\n    \"not\",\n    \"of\",\n    \"off\",\n    \"often\",\n    \"on\",\n    \"only\",\n    \"or\",\n    \"other\",\n    \"our\",\n    \"own\",\n    \"rather\",\n    \"said\",\n    \"say\",\n    \"says\",\n    \"she\",\n    \"should\",\n    \"since\",\n    \"so\",\n    \"some\",\n    \"than\",\n    \"that\",\n    \"the\",\n    \"their\",\n    \"them\",\n    \"then\",\n    \"there\",\n    \"these\",\n    \"they\",\n    \"this\",\n    \"tis\",\n    \"to\",\n    \"too\",\n    \"twas\",\n    \"us\",\n    \"wants\",\n    \"was\",\n    \"we\",\n    \"were\",\n    \"what\",\n    \"when\",\n    \"where\",\n    \"which\",\n    \"while\",\n    \"who\",\n    \"whom\",\n    \"why\",\n    \"will\",\n    \"with\",\n    \"would\",\n    \"yet\",\n    \"you\",\n    \"your\"\n  ]\n\n  if (stopWords.indexOf(token) === -1) return token\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to pass through the filter"}],"has_params":true,"tags":[{"type":"module","string":""},{"type":"param","types":["String"],"name":"token","description":"The token to pass through the filter"},{"type":"returns","string":"{String}"},{"type":"see","local":"lunr.Pipeline","visibility":"lunr.Pipeline"}],"module":true,"related":{"href":""},"has_related":true,"methods":[]},{"id":"39-1361873428990","name":"TokenStore","signiture":"lunr.TokenStore()","type":"method","ctx":{"type":"method","receiver":"lunr","name":"TokenStore","string":"lunr.TokenStore()"},"description":{"full":"<p>lunr.TokenStore is used for efficient storing and lookup of the reverse<br />index of token to document ref.</p>","summary":"<p>lunr.TokenStore is used for efficient storing and lookup of the reverse<br />index of token to document ref.</p>","body":""},"full_description":"<p>lunr.TokenStore is used for efficient storing and lookup of the reverse index of token to document ref.</p>","code":"lunr.TokenStore = function () {\n  this.root = { docs: {} }\n  this.length = 0\n}","params":[],"has_params":false,"tags":[{"type":"constructor","string":""}],"module":true,"related":{"href":""},"has_related":true,"methods":[{"id":"40-1361873428990","name":"add","signiture":"lunr.TokenStore.prototype.add()","type":"method","ctx":{"type":"method","receiver":"lunr.TokenStore.prototype","name":"add","string":"lunr.TokenStore.prototype.add()"},"description":{"full":"<p>Adds a new token doc pair to the store.</p>\n\n<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>","summary":"<p>Adds a new token doc pair to the store.</p>","body":"<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>"},"full_description":"<p>Adds a new token doc pair to the store.</p>\n\n<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>","code":"lunr.TokenStore.prototype.add = function (token, doc, root) {\n  var root = root || this.root,\n      key = token[0],\n      rest = token.slice(1)\n\n  if (!(key in root)) root[key] = {docs: {}}\n\n  if (rest.length === 0) {\n    root[key].docs[doc.ref] = doc\n    this.length += 1\n    return\n  } else {\n    return this.add(rest, doc, root[key])\n  }\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to store the doc under"},{"type":"param","types":["Object"],"name":"doc","description":"The doc to store against the token"},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start looking for the"}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"token","description":"The token to store the doc under"},{"type":"param","types":["Object"],"name":"doc","description":"The doc to store against the token"},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start looking for the"},{"type":"correct","string":"place to enter the doc, by default the root of this lunr.TokenStore"},{"type":"is","string":"used."},{"type":"memberOf","parent":"TokenStore"}],"module":false,"parent":"TokenStore","related":{"href":""},"has_related":true},{"id":"41-1361873428990","name":"has","signiture":"lunr.TokenStore.prototype.has()","type":"method","ctx":{"type":"method","receiver":"lunr.TokenStore.prototype","name":"has","string":"lunr.TokenStore.prototype.has()"},"description":{"full":"<p>Checks whether this key is contained within this lunr.TokenStore.</p>\n\n<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>","summary":"<p>Checks whether this key is contained within this lunr.TokenStore.</p>","body":"<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>"},"full_description":"<p>Checks whether this key is contained within this lunr.TokenStore.</p>\n\n<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>","code":"lunr.TokenStore.prototype.has = function (token, root) {\n  var root = root || this.root,\n      key = token[0],\n      rest = token.slice(1)\n\n  if (!(key in root)) return false\n\n  if (rest.length === 0) {\n    return true\n  } else {\n    return this.has(rest, root[key])\n  }\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to check for"},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start"}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"token","description":"The token to check for"},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start"},{"type":"memberOf","parent":"TokenStore"}],"module":false,"parent":"TokenStore","related":{"href":""},"has_related":true},{"id":"42-1361873428990","name":"getNode","signiture":"lunr.TokenStore.prototype.getNode()","type":"method","ctx":{"type":"method","receiver":"lunr.TokenStore.prototype","name":"getNode","string":"lunr.TokenStore.prototype.getNode()"},"description":{"full":"<p>Retrieve a node from the token store for a given token.</p>\n\n<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>","summary":"<p>Retrieve a node from the token store for a given token.</p>","body":"<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>"},"full_description":"<p>Retrieve a node from the token store for a given token.</p>\n\n<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>","code":"lunr.TokenStore.prototype.getNode = function (token, root) {\n  var root = root || this.root,\n      key = token[0],\n      rest = token.slice(1)\n\n  if (!(key in root)) return {}\n\n  if (rest.length === 0) {\n    return root[key]\n  } else {\n    return this.getNode(rest, root[key])\n  }\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to get the node for."},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"token","description":"The token to get the node for."},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start."},{"type":"returns","string":"{Object}"},{"type":"see","local":"TokenStore.prototype.get","visibility":"TokenStore.prototype.get"},{"type":"memberOf","parent":"TokenStore"}],"module":false,"parent":"TokenStore","related":{"href":""},"has_related":true},{"id":"43-1361873428990","name":"get","signiture":"lunr.TokenStore.prototype.get()","type":"method","ctx":{"type":"method","receiver":"lunr.TokenStore.prototype","name":"get","string":"lunr.TokenStore.prototype.get()"},"description":{"full":"<p>Retrieve the documents for a node for the given token.</p>\n\n<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>","summary":"<p>Retrieve the documents for a node for the given token.</p>","body":"<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>"},"full_description":"<p>Retrieve the documents for a node for the given token.</p>\n\n<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>","code":"lunr.TokenStore.prototype.get = function (token, root) {\n  return this.getNode(token).docs || {}\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to get the documents for."},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"token","description":"The token to get the documents for."},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start."},{"type":"returns","string":"{Object}"},{"type":"memberOf","parent":"TokenStore"}],"module":false,"parent":"TokenStore","related":{"href":""},"has_related":true},{"id":"44-1361873428991","name":"remove","signiture":"lunr.TokenStore.prototype.remove()","type":"method","ctx":{"type":"method","receiver":"lunr.TokenStore.prototype","name":"remove","string":"lunr.TokenStore.prototype.remove()"},"description":{"full":"<p>Remove the document identified by ref from the token in the store.</p>\n\n<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>","summary":"<p>Remove the document identified by ref from the token in the store.</p>","body":"<p>By default this function starts at the root of the current store, however<br />it can start at any node of any token store if required.</p>"},"full_description":"<p>Remove the document identified by ref from the token in the store.</p>\n\n<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>","code":"lunr.TokenStore.prototype.remove = function (token, ref, root) {\n  var root = root || this.root,\n      key = token[0],\n      rest = token.slice(1)\n\n  if (!(key in root)) return\n\n  if (rest.length === 0) {\n    delete root[key].docs[ref]\n  } else {\n    return this.remove(rest, ref, root[key])\n  }\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to get the documents for."},{"type":"param","types":["String"],"name":"ref","description":"The ref of the document to remove from this token."},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"token","description":"The token to get the documents for."},{"type":"param","types":["String"],"name":"ref","description":"The ref of the document to remove from this token."},{"type":"param","types":["Object"],"name":"root","description":"An optional node at which to start."},{"type":"returns","string":"{Object}"},{"type":"memberOf","parent":"TokenStore"}],"module":false,"parent":"TokenStore","related":{"href":""},"has_related":true},{"id":"45-1361873428991","name":"expand","signiture":"lunr.TokenStore.prototype.expand()","type":"method","ctx":{"type":"method","receiver":"lunr.TokenStore.prototype","name":"expand","string":"lunr.TokenStore.prototype.expand()"},"description":{"full":"<p>Find all the possible suffixes of the passed token using tokens<br />currently in the store.</p>","summary":"<p>Find all the possible suffixes of the passed token using tokens<br />currently in the store.</p>","body":""},"full_description":"<p>Find all the possible suffixes of the passed token using tokens currently in the store.</p>","code":"lunr.TokenStore.prototype.expand = function (token, memo) {\n  var root = this.getNode(token),\n      docs = root.docs || {},\n      memo = memo || []\n\n  if (Object.keys(docs).length) memo.push(token)\n\n  Object.keys(root)\n    .forEach(function (key) {\n      if (key === 'docs') return\n\n      memo.concat(this.expand(token + key, memo))\n    }, this)\n\n  return memo\n}","params":[{"type":"param","types":["String"],"name":"token","description":"The token to expand."}],"has_params":true,"tags":[{"type":"param","types":["String"],"name":"token","description":"The token to expand."},{"type":"returns","string":"{Array}"},{"type":"memberOf","parent":"TokenStore"}],"module":false,"parent":"TokenStore","related":{"href":""},"has_related":true}]}]
  </script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js" type="text/javascript" charset="utf-8"></script>

  <script type="text/javascript" charset="utf-8">
    // lunr.js version: 0.0.4
    // (c) 2011 Oliver Nightingale
    //
    //  Released under MIT license.
    //
    var Lunr=function(c,f){var b=new Lunr.Index(c);f.call(b,b);return b};
    Lunr.utils={uniq:function(c){if(!c)return[];return c.reduce(function(c,b){c.indexOf(b)===-1&&c.push(b);return c},[])},intersect:function(c){var f=[].slice.call(arguments,1);return this.uniq(c).filter(function(b){return f.every(function(a){return a.indexOf(b)>=0})})},detect:function(c,f,b){for(var a=c.length,g=null,d=0;d<a;d++)if(f.call(b,c[d],d,c)){g=c[d];break}return g},copy:function(c){return Object.keys(c).reduce(function(f,b){f[b]=c[b];return f},{})}};
    Lunr.Trie=function(){var c=function(){this.children={};this.values=[]};c.prototype={childForKey:function(b){var a=this.children[b];a||(a=new c,this.children[b]=a);return a}};var f=function(){this.root=new c};f.prototype={get:function(b){var a=this;return this.keys(b).reduce(function(c,d){a.getNode(d).values.forEach(function(a){a=Lunr.utils.copy(a);if(b===d)a.exact=!0;c.push(a)});return c},[])},getNode:function(b){var a=function(b,d){if(!d.length)return b;return a(b.childForKey(d.charAt(0)),d.slice(1))};
    return a(this.root,b)},keys:function(b){var a=[];b=b||"";var c=function(b,e){b.values.length&&a.push(e);Object.keys(b.children).forEach(function(a){c(b.children[a],e+a)})};c(this.getNode(b),b);return a},set:function(b,a){var c=function(b,e){if(!e.length)return b.values.push(a);c(b.childForKey(e.charAt(0)),e.slice(1))};return c(this.root,b)}};return f}();Lunr.Index=function(c){this.name=c;this.refName="id";this.fields={};this.trie=new Lunr.Trie};
    Lunr.Index.prototype={add:function(c){(new Lunr.Document(c,this.refName,this.fields)).words().forEach(function(c){this.trie.set(c.id,c.docs[0])},this)},field:function(c,f){this.fields[c]=f||{multiplier:1}},ref:function(c){this.refName=c},search:function(c){if(!c)return[];c=c.split(" ").map(function(c){c=new Lunr.Word(c);if(!c.isStopWord())return c.toString()}).filter(function(c){return c}).map(function(c){return this.trie.get(c).sort(function(b,a){if(b.exact&&a.exact===void 0)return-1;if(a.exact&&
    b.exact===void 0)return 1;if(b.score<a.score)return 1;if(b.score>a.score)return-1;return 0}).map(function(b){return b.documentId})},this);return Lunr.utils.intersect.apply(Lunr.utils,c)}};Lunr.Document=function(c,f,b){this.original=c;this.fields=b;this.ref=c[f]};
    Lunr.Document.prototype={asJSON:function(){return{id:this.ref,words:this.words().map(function(c){return c.id}),original:this.original}},words:function(){var c=this,f={};Object.keys(this.fields).forEach(function(b){c.original[b].split(/\b/g).filter(function(a){return!!a.match(/\w/)}).map(function(a){a=new Lunr.Word(a);if(!a.isStopWord())return a.toString()}).filter(function(a){return a}).forEach(function(a){f[a]||(f[a]={score:0,ref:c.ref});f[a].score+=c.fields[b].multiplier})});return Object.keys(f).map(function(b){return{id:b,
    docs:[{score:f[b].score,documentId:c.ref}]}})}};Lunr.Word=function(c){this.raw=c;this.out=this.raw.replace(/^\W+/,"").replace(/\W+$/,"").toLowerCase()};Lunr.Word.stopWords=["the","of","to","and","a","in","is","it","you","that","this"];
    Lunr.Word.prototype={isStopWord:function(){return Lunr.Word.stopWords.indexOf(this.raw.toLowerCase())!==-1},toString:function(){if(!this.isStopWord())return this.stem(),this.out},stem:function(){var c={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},f={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",
    ful:"",ness:""};return function(){var b,a,g,d=g=this.out;if(g.length<3)return g;var e,h;g=g.substr(0,1);g=="y"&&(d=g.toUpperCase()+d.substr(1));e=/^(.+?)(ss|i)es$/;a=/^(.+?)([^s])s$/;e.test(d)?d=d.replace(e,"$1$2"):a.test(d)&&(d=d.replace(a,"$1$2"));e=/^(.+?)eed$/;a=/^(.+?)(ed|ing)$/;e.test(d)?(a=e.exec(d),e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(a[1])&&(e=/.$/,d=d.replace(e,""))):a.test(d)&&(a=a.exec(d),b=a[1],a=/^([^aeiou][^aeiouy]*)?[aeiouy]/,a.test(b)&&(d=b,a=/(at|bl|iz)$/,
    h=/([^aeiouylsz])\1$/,b=/^[^aeiou][^aeiouy]*[aeiouy][^aeiouwxy]$/,a.test(d)?d+="e":h.test(d)?(e=/.$/,d=d.replace(e,"")):b.test(d)&&(d+="e")));e=/^(.+?)y$/;e.test(d)&&(a=e.exec(d),b=a[1],e=/^([^aeiou][^aeiouy]*)?[aeiouy]/,e.test(b)&&(d=b+"i"));e=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;e.test(d)&&(a=e.exec(d),b=a[1],a=a[2],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(b)&&(d=b+c[a]));
    e=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;e.test(d)&&(a=e.exec(d),b=a[1],a=a[2],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(b)&&(d=b+f[a]));e=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;a=/^(.+?)(s|t)(ion)$/;e.test(d)?(a=e.exec(d),b=a[1],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,e.test(b)&&(d=b)):a.test(d)&&(a=a.exec(d),b=a[1]+a[2],a=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,
    a.test(b)&&(d=b));e=/^(.+?)e$/;if(e.test(d)&&(a=e.exec(d),b=a[1],e=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/,a=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*([aeiouy][aeiou]*)?$/,h=/^[^aeiou][^aeiouy]*[aeiouy][^aeiouwxy]$/,e.test(b)||a.test(b)&&!h.test(b)))d=b;e=/ll$/;a=/^([^aeiou][^aeiouy]*)?[aeiouy][aeiou]*[^aeiou][^aeiouy]*[aeiouy][aeiou]*[^aeiou][^aeiouy]*/;e.test(d)&&a.test(d)&&(e=/.$/,d=d.replace(e,""));g=="y"&&(d=g.toLowerCase()+
    d.substr(1));this.out=d}}()};
  </script>

  <script type="text/javascript" charset="utf-8">
    var idx = Lunr('methods', function () {
      this.ref('id')
      this.field('name', { multiplier: 10 })
      this.field('parent', { multiplier: 5 })
      this.field('full_description')
    })

    var methods = raw.reduce(function (memo, module) {
      return memo.concat(module.methods)
    }, [])

    methods.forEach(function (method) {
      idx.add(method)
    })

    $(document).ready(function () {

      var search = function (term) {
        return idx.search(term).map(function (id) {
          return methods.filter(function (method) {
            return method.id === id
          })[0]
        })
      }

      var searchResults = $('#search-results')

      $('#search-input').keyup(function () {
        var query = $(this).val(),
            results = search(query)

        if (!results.length) {
          searchResults.empty()
          return
        };

        var resultsList = results.reduce(function (ul, result) {
          var li = $('<li>').append($('<a>', {
            href: '#' + result.name,
            text: result.name
          }))

          ul.append(li)

          return ul
        }, $('<ul>'))

        searchResults.html(resultsList)
      })
    })
  </script>

  <style type="text/css" media="screen">
    body {
  font-family: 'Helvetica Neue';
  color: #333;
}

a {
  color: #0f4bf0;
}

header h1 {
  border-top: 4px solid #333;
  font-size: 2.6em;
}

header .version {
  font-size: 0.6em;
}

.main > header {
  margin-bottom: 40px;
}

article {
  margin-bottom: 10px;
  padding-bottom: 30px;
}

article header h2 {
  border-top: 3px solid #333;
  font-size: 2em;
  padding-top: 5px;
}

article > section {
  margin-bottom: 30px;
}

article section h3 {
  font-size: 1em;
}

article section header h3 {
  padding-top: 2px;
  font-size: 1.2em;
  margin-bottom: 5px;
  border-top: 2px solid #333;
}

article section header h4 {
  font-size: 0.9em;
  font-family: courier;
  margin: 2px 0 5px 0;
}

@-webkit-keyframes highlight {
  from {
    background-color: #Ffff66;
  }

  to {
    background-color: white;
  }
}

section.method:target {
  -webkit-animation-duration: 1s;
  -webkit-animation-name: highlight;
}

section header .type, section header .related {
  margin-top: 0px;
  font-size: 0.8em;
}

section.params h4, section.source h4 {
  margin-top: 5px;
  margin-bottom: 2px;
  font-size: 0.9em;
}

section.params ul {
  margin-top: 2px;
}

a.show-source {
  font-size: 0.8em;
}

.wrap {
  width: 960px;
  margin: 0 auto;
}

.main {
  width: 760px;
  float: left;
}

.search {
  margin-top: 10px;
  float: right;
}

#search-input {
  width: 200px;
}

#search-results {
  position: relative;
}

#search-results ul {
  width: 200px;
  position: absolute;
  top: 0px;
  left: 0px;
  background-color: white;
  border: 1px solid #ccc;
  list-style: none;
  padding: 0;
  margin-top: 0;
  font-size: 0.9em;
}

#search-results li {
  padding: 5px;
}

#search-results li:hover {
  background-color: #eee;
  cursor: pointer;
}

#search-results li a {
  text-decoration: none;
  width: 200px;
  display: block;
}

p {
  line-height: 1.4em;
}

nav {
  padding-top: 15px;
  float: left;
  width: 165px;
  margin-right: 30px;
  text-align: right;
  font-size: 0.8em;
}

nav ul {
  list-style: none;
  margin: 0;
  padding: 0;
}

nav ul h3 {
  margin-bottom: 5px;
  border-top: 2px solid #CCC;
  padding-top: 2px;
}

nav ul ul li {
  padding: 2px 0;
}

pre {
  background-color: rgba(0,0,0,0.1);
  padding: 8px;
}

code .keyword, code .special {
  font-weight: bold;
  color: black;
}

code .string, code .regexp {
  color: green
}

code .class { 
  color: blue
}

code .number {
  color: red
}

code .comment {
  color: grey;
  font-style: italic;
}
  </style>
</head>
<body>
  <div class='wrap'>


    <nav>
      <ul>
        
          <li>
            <a href='#lunr'>
              <h3>lunr</h3>
            </a>

            <ul>
              
            </ul>
          </li>
        
          <li>
            <a href='#tokenizer'>
              <h3>tokenizer</h3>
            </a>

            <ul>
              
            </ul>
          </li>
        
          <li>
            <a href='#Pipeline'>
              <h3>Pipeline</h3>
            </a>

            <ul>
              
                <li><a href='#add'>add</a></li>
              
                <li><a href='#after'>after</a></li>
              
                <li><a href='#before'>before</a></li>
              
                <li><a href='#remove'>remove</a></li>
              
                <li><a href='#run'>run</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#Vector'>
              <h3>Vector</h3>
            </a>

            <ul>
              
                <li><a href='#magnitude'>magnitude</a></li>
              
                <li><a href='#dot'>dot</a></li>
              
                <li><a href='#similarity'>similarity</a></li>
              
                <li><a href='#toArray'>toArray</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#SortedSet'>
              <h3>SortedSet</h3>
            </a>

            <ul>
              
                <li><a href='#add'>add</a></li>
              
                <li><a href='#toArray'>toArray</a></li>
              
                <li><a href='#map'>map</a></li>
              
                <li><a href='#forEach'>forEach</a></li>
              
                <li><a href='#indexOf'>indexOf</a></li>
              
                <li><a href='#locationFor'>locationFor</a></li>
              
                <li><a href='#intersect'>intersect</a></li>
              
                <li><a href='#clone'>clone</a></li>
              
                <li><a href='#union'>union</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#Index'>
              <h3>Index</h3>
            </a>

            <ul>
              
                <li><a href='#field'>field</a></li>
              
                <li><a href='#ref'>ref</a></li>
              
                <li><a href='#add'>add</a></li>
              
                <li><a href='#remove'>remove</a></li>
              
                <li><a href='#update'>update</a></li>
              
                <li><a href='#idf'>idf</a></li>
              
                <li><a href='#search'>search</a></li>
              
                <li><a href='#documentVector'>documentVector</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#Store'>
              <h3>Store</h3>
            </a>

            <ul>
              
                <li><a href='#set'>set</a></li>
              
                <li><a href='#get'>get</a></li>
              
                <li><a href='#has'>has</a></li>
              
                <li><a href='#remove'>remove</a></li>
              
            </ul>
          </li>
        
          <li>
            <a href='#stemmer'>
              <h3>stemmer</h3>
            </a>

            <ul>
              
            </ul>
          </li>
        
          <li>
            <a href='#stopWordFilter'>
              <h3>stopWordFilter</h3>
            </a>

            <ul>
              
            </ul>
          </li>
        
          <li>
            <a href='#TokenStore'>
              <h3>TokenStore</h3>
            </a>

            <ul>
              
                <li><a href='#add'>add</a></li>
              
                <li><a href='#has'>has</a></li>
              
                <li><a href='#getNode'>getNode</a></li>
              
                <li><a href='#get'>get</a></li>
              
                <li><a href='#remove'>remove</a></li>
              
                <li><a href='#expand'>expand</a></li>
              
            </ul>
          </li>
        
      </ul>
    </nav>

    <div class='main'>
      <header>
        <div class='search'>
          <input type="search" id="search-input" placeholder="Search"></input>
          <div id="search-results"></div>
        </div>
        <h1>lunr.js <span class='version'>0.2.0</span></h1>
      </header>

      
        <article id='lunr'>
          <header>
            <h2>lunr</h2>
          </header>

          <section>
            <p>Convinience function for instantiating a new lunr index and configuring it with the default pipeline functions and the passed config function.</p>

<p>When using this convinience function a new index will be created with the following functions already in the pipeline:</p>

<p>lunr.StopWordFilter - filters out any stop words before they enter the index</p>

<p>lunr.stemmer - stems the tokens before entering the index.</p>

<p>Example:</p>

<pre><code>var idx = lunr(function () {
  this.field('title', 10)
  this.field('tags', 100)
  this.field('body')

  this.ref('cid')

  this.pipeline.add(function () {
    // some custome pipeline function
  })

})
</code></pre>
          </section>

          
        </article>
      
        <article id='tokenizer'>
          <header>
            <h2>tokenizer</h2>
          </header>

          <section>
            <p>A function for splitting a string into tokens ready to be insterted into the search index.</p>
          </section>

          
        </article>
      
        <article id='Pipeline'>
          <header>
            <h2>Pipeline</h2>
          </header>

          <section>
            <p>lunr.Pipelines maintain an ordered list of functions to be applied to all tokens in documents entering the search index and queries being ran against the index.</p>

<p>An instance of lunr.Index created with the lunr shortcut will contain a pipeline with a stop word filter and an English language stemmer. Extra functions can be added before or after either of these functions or these default functions can be removed.</p>

<p>When run the pipeline will call each function in turn, passing a token, the index of that token in the original list of all tokens and finally a list of all the original tokens.</p>

<p>The output of functions in the pipeline will be passed to the next function in the pipeline. To exclude a token from entering the index the function should return undefined, the rest of the pipeline will not be called with this token.</p>
          </section>

          
            <section class='method' id='add'>
              <header>
                <h3>add</h3>
                <h4>lunr.Pipeline.prototype.add()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>functions - Any number of functions to add to the pipeline.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Adds new functions to the end of the pipeline.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.prototype.add = function () {
  var fns = Array.prototype.slice.call(arguments)
  Array.prototype.push.apply(this._stack, fns)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='after'>
              <header>
                <h3>after</h3>
                <h4>lunr.Pipeline.prototype.after()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>existingFn - A function that already exists in the pipeline.</li>
                  
                    <li>newFn - The new function to add to the pipeline.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Adds a single function after a function that already exists in the pipeline.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.prototype.after = function (existingFn, newFn) {
  var pos = this._stack.indexOf(existingFn) + 1
  this._stack.splice(pos, 0, newFn)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='before'>
              <header>
                <h3>before</h3>
                <h4>lunr.Pipeline.prototype.before()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>existingFn - A function that already exists in the pipeline.</li>
                  
                    <li>newFn - The new function to add to the pipeline.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Adds a single function before a function that already exists in the pipeline.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.prototype.before = function (existingFn, newFn) {
  var pos = this._stack.indexOf(existingFn)
  this._stack.splice(pos, 0, newFn)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='remove'>
              <header>
                <h3>remove</h3>
                <h4>lunr.Pipeline.prototype.remove()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>fn - The function to remove from the pipeline.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Removes a function from the pipeline.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.prototype.remove = function (fn) {
  var pos = this._stack.indexOf(fn)
  this._stack.splice(pos, 1)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='run'>
              <header>
                <h3>run</h3>
                <h4>lunr.Pipeline.prototype.run()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>tokens - The tokens to run through the pipeline.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Runs the current list of functions that make up the pipeline against the passed tokens.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Pipeline.prototype.run = function (tokens) {
  var out = [],
      tokenLength = tokens.length,
      stackLength = this._stack.length

  for (var i = 0; i &lt; tokenLength; i++) {
    var token = tokens[i]

    for (var j = 0; j &lt; stackLength; j++) {
      token = this._stack[j](token, i, tokens)
      if (token === void 0) break
    };

    if (token !== void 0) out.push(token)
  };

  return out
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='Vector'>
          <header>
            <h2>Vector</h2>
          </header>

          <section>
            <p>lunr.Vectors wrap arrays and add vector related operations for the array elements.</p>
          </section>

          
            <section class='method' id='magnitude'>
              <header>
                <h3>magnitude</h3>
                <h4>lunr.Vector.prototype.magnitude()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Calculates the magnitude of this vector.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Vector.prototype.magnitude = function () {
  if (this._magnitude) return this._magnitude

  var sumOfSquares = 0,
      elems = this.elements,
      len = elems.length,
      magnitude, el

  for (var i = 0; i &lt; len; i++) {
    el = elems[i]
    sumOfSquares += el * el
  };

  return this._magnitude = Math.sqrt(sumOfSquares)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='dot'>
              <header>
                <h3>dot</h3>
                <h4>lunr.Vector.prototype.dot()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>otherVector - The vector to compute the dot product with.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Calculates the dot product of this vector and another vector.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Vector.prototype.dot = function (otherVector) {
  var elem1 = this.elements,
      elem2 = otherVector.elements,
      length = elem1.length,
      dotProduct = 0

  for (var i = 0; i &lt; length; i++) {
    dotProduct += elem1[i] * elem2[i]
  };

  return dotProduct
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='similarity'>
              <header>
                <h3>similarity</h3>
                <h4>lunr.Vector.prototype.similarity()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>otherVector - The other vector to calculate the</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Calculates the cosine similarity between this vector and another vector.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Vector.prototype.similarity = function (otherVector) {
  return this.dot(otherVector) / (this.magnitude() * otherVector.magnitude())
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='toArray'>
              <header>
                <h3>toArray</h3>
                <h4>lunr.Vector.prototype.toArray()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Converts this vector back into an array.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Vector.prototype.toArray = function () {
  return this.elements
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='SortedSet'>
          <header>
            <h2>SortedSet</h2>
          </header>

          <section>
            <p>lunr.SortedSets are used to maintain an array of uniq values in a sorted order.</p>
          </section>

          
            <section class='method' id='add'>
              <header>
                <h3>add</h3>
                <h4>lunr.SortedSet.prototype.add()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>The - objects to add to this set.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Inserts new items into the set in the correct position to maintain the order.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.add = function () {
  Array.prototype.slice.call(arguments).forEach(function (element) {
    if (~this.elements.indexOf(element)) return
    this.elements.splice(this.locationFor(element), 0, element)
  }, this)

  this.length = this.elements.length
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='toArray'>
              <header>
                <h3>toArray</h3>
                <h4>lunr.SortedSet.prototype.toArray()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Converts this sorted set into an array.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.toArray = function () {
  return this.elements.slice()
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='map'>
              <header>
                <h3>map</h3>
                <h4>lunr.SortedSet.prototype.map()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>fn - The function that is called on each element of the</li>
                  
                    <li>ctx - An optional object that can be used as the context</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Creates a new array with the results of calling a provided function on every element in this sorted set.</p>

<p>Delegates to Array.prototype.map and has the same signature.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.map = function (fn, ctx) {
  return this.elements.map(fn, ctx)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='forEach'>
              <header>
                <h3>forEach</h3>
                <h4>lunr.SortedSet.prototype.forEach()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>fn - The function that is called on each element of the</li>
                  
                    <li>ctx - An optional object that can be used as the context</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Executes a provided function once per sorted set element.</p>

<p>Delegates to Array.prototype.forEach and has the same signature.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.forEach = function (fn, ctx) {
  return this.elements.forEach(fn, ctx)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='indexOf'>
              <header>
                <h3>indexOf</h3>
                <h4>lunr.SortedSet.prototype.indexOf()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>elem - The object to locate in the sorted set.</li>
                  
                    <li>startIndex - The index at which to begin the search.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Returns the first index at which a given element can be found in the sorted set, or -1 if it is not present.</p>

<p>Delegates to Array.prototype.indexOf and has the same signature.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.indexOf = function (elem, startIndex) {
  return this.elements.indexOf(elem)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='locationFor'>
              <header>
                <h3>locationFor</h3>
                <h4>lunr.SortedSet.prototype.locationFor()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>elem - The elem to find the position for in the set</li>
                  
                    <li>start - An optional index at which to start searching from</li>
                  
                    <li>end - An optional index at which to stop search from within</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Returns the position within the sorted set that an element should be inserted at to maintain the current order of the set.</p>

<p>This function assumes that the element to search for does not already exist in the sorted set.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.locationFor = function (elem, start, end) {
  var start = start || 0,
      end = end || this.elements.length,
      sectionLength = end - start,
      pivot = start + Math.floor(sectionLength / 2),
      pivotElem = this.elements[pivot]

  if (sectionLength &lt;= 1) {
    if (pivotElem &gt; elem) return pivot
    if (pivotElem &lt; elem) return pivot + 1
  }

  if (pivotElem &lt; elem) return this.locationFor(elem, pivot, end)
  if (pivotElem &gt; elem) return this.locationFor(elem, start, pivot)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='intersect'>
              <header>
                <h3>intersect</h3>
                <h4>lunr.SortedSet.prototype.intersect()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>otherSet - The set to intersect with this set.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Creates a new lunr.SortedSet that contains the elements in the intersection of this set and the passed set.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.intersect = function (otherSet) {
  var intersectSet = new lunr.SortedSet,
      i = 0, j = 0,
      a_len = this.length, b_len = otherSet.length,
      a = this.elements, b = otherSet.elements

  while (true) {
    if (i &gt; a_len - 1 || j &gt; b_len - 1) break

    if (a[i] === b[j]) {
      intersectSet.add(a[i])
      i++, j++
      continue
    }

    if (a[i] &lt; b[j]) {
      i++
      continue
    }

    if (a[i] &gt; b[j]) {
      j++
      continue
    }
  };

  return intersectSet
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='clone'>
              <header>
                <h3>clone</h3>
                <h4>lunr.SortedSet.prototype.clone()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                <ul>
                  
                </ul>
              </section>

              

              <section>
                <p>Makes a copy of this set</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.clone = function () {
  var clone = new lunr.SortedSet

  clone.elements = this.toArray()
  clone.length = clone.elements.length

  return clone
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='union'>
              <header>
                <h3>union</h3>
                <h4>lunr.SortedSet.prototype.union()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>otherSet - The set to union with this set.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Creates a new lunr.SortedSet that contains the elements in the union of this set and the passed set.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.SortedSet.prototype.union = function (otherSet) {
  var longSet, shortSet, unionSet

  if (this.length &gt;= otherSet.length) {
    longSet = this, shortSet = otherSet
  } else {
    longSet = otherSet, shortSet = this
  }

  unionSet = longSet.clone()

  unionSet.add.apply(unionSet, shortSet.toArray())

  return unionSet
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='Index'>
          <header>
            <h2>Index</h2>
          </header>

          <section>
            <p>lunr.Index is object that manages a search index.  It contains the indexes and stores all the tokens and document lookups.  It also provides the main user facing API for the library.</p>
          </section>

          
            <section class='method' id='field'>
              <header>
                <h3>field</h3>
                <h4>lunr.Index.prototype.field()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>fieldName - The name of the field within the document that</li>
                  
                    <li>boost - An optional boost that can be applied to terms in this</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Adds a field to the list of fields that will be searchable within documents in the index.</p>

<p>An optional boost param can be passed to affect how much tokens in this field rank in search results, by default the boost value is 1.</p>

<p>Fields should be added before any documents are added to the index, fields that are added after documents are added to the index will only apply to new documents added to the index.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.field = function (fieldName, opts) {
  var opts = opts || {},
      field = { name: fieldName, boost: opts.boost || 1 }

  this._fields.push(field)
  return this
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='ref'>
              <header>
                <h3>ref</h3>
                <h4>lunr.Index.prototype.ref()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>refName - The property to use to uniquely identify the</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Sets the property used to uniquely indetify documents added to the index, by default this property is 'id'.</p>

<p>This should only be changed before adding documents to the index, changing the ref property without resetting the index can lead to unexpected results.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.ref = function (refName) {
  this._ref = refName
  return this
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='add'>
              <header>
                <h3>add</h3>
                <h4>lunr.Index.prototype.add()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>doc - The document to add to the index.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Add a document to the index.</p>

<p>This is the way new documents enter the index, this function will run the fields from the document through the index's pipeline and then add it to the index, it will then show up in search results.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.add = function (doc) {
  var docTokens = {},
      allDocumentTokens = new lunr.SortedSet,
      docRef = doc[this._ref]

  this._fields.forEach(function (field) {
    var fieldTokens = this.pipeline.run(lunr.tokenizer(doc[field.name]))

    docTokens[field.name] = fieldTokens
    lunr.SortedSet.prototype.add.apply(allDocumentTokens, fieldTokens)
  }, this)

  this.documentStore.set(docRef, allDocumentTokens)
  lunr.SortedSet.prototype.add.apply(this.corpusTokens, allDocumentTokens.toArray())

  for (var i = 0; i &lt; allDocumentTokens.length; i++) {
    var token = allDocumentTokens.elements[i]
    var tf = this._fields.reduce(function (memo, field) {
      var tokenCount = docTokens[field.name].filter(function (t) { return t === token }).length,
          fieldLength = docTokens[field.name].length

      return memo + (tokenCount / fieldLength * field.boost)
    }, 0)

    this.tokenStore.add(token, { ref: docRef, tf: tf })
  };
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='remove'>
              <header>
                <h3>remove</h3>
                <h4>lunr.Index.prototype.remove()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>doc - The document to remove from the index.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Removes a document from the index.</p>

<p>To make sure documents no longer show up in search results they can be removed from the index using this method.</p>

<p>The document passed only needs to have the same ref property value as the document that was added to the index, they could be completly different objects.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.remove = function (doc) {
  var docRef = doc[this._ref],
      docTokens = this.documentStore.get(docRef)

  this.documentStore.remove(docRef)

  docTokens.forEach(function (token) {
    this.tokenStore.remove(token, docRef)
  }, this)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='update'>
              <header>
                <h3>update</h3>
                <h4>lunr.Index.prototype.update()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>doc - The document to update in the index.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Updates a document in the index.</p>

<p>When a document contained within the index gets updated, fields changed, added or removed, to make sure it correctly matched against search queries, it should be updated in the index.</p>

<p>This method is just a wrapper around <code>remove</code> and <code>add</code></p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.update = function (doc) {
  this.remove(doc)
  this.add(doc)
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='idf'>
              <header>
                <h3>idf</h3>
                <h4>lunr.Index.prototype.idf()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>token - The token to calculate the idf of.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Calculates the inverse document frequency for a token within the index.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.idf = function (term) {
  var documentFrequency = Object.keys(this.tokenStore.get(term)).length

  if (documentFrequency === 0) {
    return 1
  } else {
    return 1 + Math.log(this.tokenStore.length / documentFrequency)
  }
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='search'>
              <header>
                <h3>search</h3>
                <h4>lunr.Index.prototype.search()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>query - The query to search the index with.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Searches the index using the passed query.</p>

<p>Queries should be a string, multiple words are allowed and will lead to an AND based query, e.g. <code>idx.search('foo bar')</code> will run a search for documents containing both 'foo' and 'bar'.</p>

<p>All query tokens are passed through the same pipeline that document tokens are passed through, so any lanugage processing involved will be run on every query term.</p>

<p>Each query term is expanded, so that the term 'he' might be expanded to 'hello' and 'help' if those terms were already included in the index.</p>

<p>Matching documents are returned as an array of objects, each object contains the matching document ref, as set for this index, and the similarity score for this document against the query.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.search = function (query) {
  var queryTokens = this.pipeline.run(lunr.tokenizer(query)),
      queryArr = new Array (this.corpusTokens.length),
      documentSets = [],
      fieldBoosts = this._fields.reduce(function (memo, f) { return memo + f.boost }, 0)

  if (!queryTokens.some(lunr.TokenStore.prototype.has, this.tokenStore)) return []

  queryTokens
    .forEach(function (token, i, tokens) {
      var tf = 1 / tokens.length * this._fields.length * fieldBoosts,
          self = this

      var set = this.tokenStore.expand(token).reduce(function (memo, key) {
        var pos = self.corpusTokens.indexOf(key),
            idf = self.idf(key),
            set = new lunr.SortedSet

        if (pos &gt; -1) queryArr[pos] = tf * idf

        Object.keys(self.tokenStore.get(key)).forEach(function (ref) { set.add(ref) })

        return memo.union(set)
      }, new lunr.SortedSet)

      documentSets.push(set)
    }, this)

  var documentSet = documentSets.reduce(function (memo, set) {
    return memo.intersect(set)
  })

  var queryVector = new lunr.Vector (queryArr)

  return documentSet
    .map(function (ref) {
      return { ref: ref, score: queryVector.similarity(this.documentVector(ref)) }
    }, this)
    .sort(function (a, b) {
      return b.score - a.score
    })
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='documentVector'>
              <header>
                <h3>documentVector</h3>
                <h4>lunr.Index.prototype.documentVector()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>documentRef - The ref to find the document with.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Generates a vector containing all the tokens in the document matching the passed documentRef.</p>

<p>The vector contains the tf-idf score for each token contained in the document with the passed documentRef.  The vector will contain an element for every token in the indexes corpus, if the document does not contain that token the element will be 0.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Index.prototype.documentVector = function (documentRef) {
  var documentTokens = this.documentStore.get(documentRef),
      documentTokensLength = documentTokens.length,
      documentArr = new Array (this.corpusTokens.length)

  for (var i = 0; i &lt; documentTokensLength; i++) {
    var token = documentTokens.elements[i],
        tf = this.tokenStore.get(token)[documentRef].tf,
        idf = this.idf(token)

    documentArr[this.corpusTokens.indexOf(token)] = tf * idf
  };

  return new lunr.Vector (documentArr)
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='Store'>
          <header>
            <h2>Store</h2>
          </header>

          <section>
            <p>lunr.Store is a simple key-value store used for storing sets of tokens for documents stored in index.</p>
          </section>

          
            <section class='method' id='set'>
              <header>
                <h3>set</h3>
                <h4>lunr.Store.prototype.set()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>id - The key used to store the tokens against.</li>
                  
                    <li>tokens - The tokens to store against the key.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Stores the given tokens in the store against the given id.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Store.prototype.set = function (id, tokens) {
  this.store[id] = tokens
  this.length = Object.keys(this.store).length
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='get'>
              <header>
                <h3>get</h3>
                <h4>lunr.Store.prototype.get()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>id - The key to lookup and retrieve from the store.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Retrieves the tokens from the store for a given key.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Store.prototype.get = function (id) {
  return this.store[id]
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='has'>
              <header>
                <h3>has</h3>
                <h4>lunr.Store.prototype.has()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>id - The id to look up in the store.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Checks whether the store contains a key.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Store.prototype.has = function (id) {
  return id in this.store
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='remove'>
              <header>
                <h3>remove</h3>
                <h4>lunr.Store.prototype.remove()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>id - The id to remove from the store.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Removes the value for a key in the store.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.Store.prototype.remove = function (id) {
  if (!this.has(id)) return

  delete this.store[id]
  this.length--
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
        <article id='stemmer'>
          <header>
            <h2>stemmer</h2>
          </header>

          <section>
            <p>lunr.stemmer is an english language stemmer, this is a JavaScript implementation of the PorterStemmer taken from <a href='http://tartaurs.org/~martin'>http://tartaurs.org/~martin</a></p>
          </section>

          
        </article>
      
        <article id='stopWordFilter'>
          <header>
            <h2>stopWordFilter</h2>
          </header>

          <section>
            <p>lunr.stopWordFilter is an English language stop word list filter, any words contained in the list will not be passed through the filter.</p>

<p>This is intented to be used in the Pipeline. If the token does not pass the filter then undefined will be returned.</p>
          </section>

          
        </article>
      
        <article id='TokenStore'>
          <header>
            <h2>TokenStore</h2>
          </header>

          <section>
            <p>lunr.TokenStore is used for efficient storing and lookup of the reverse index of token to document ref.</p>
          </section>

          
            <section class='method' id='add'>
              <header>
                <h3>add</h3>
                <h4>lunr.TokenStore.prototype.add()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>token - The token to store the doc under</li>
                  
                    <li>doc - The doc to store against the token</li>
                  
                    <li>root - An optional node at which to start looking for the</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Adds a new token doc pair to the store.</p>

<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.TokenStore.prototype.add = function (token, doc, root) {
  var root = root || this.root,
      key = token[0],
      rest = token.slice(1)

  if (!(key in root)) root[key] = {docs: {}}

  if (rest.length === 0) {
    root[key].docs[doc.ref] = doc
    this.length += 1
    return
  } else {
    return this.add(rest, doc, root[key])
  }
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='has'>
              <header>
                <h3>has</h3>
                <h4>lunr.TokenStore.prototype.has()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>token - The token to check for</li>
                  
                    <li>root - An optional node at which to start</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Checks whether this key is contained within this lunr.TokenStore.</p>

<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.TokenStore.prototype.has = function (token, root) {
  var root = root || this.root,
      key = token[0],
      rest = token.slice(1)

  if (!(key in root)) return false

  if (rest.length === 0) {
    return true
  } else {
    return this.has(rest, root[key])
  }
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='getNode'>
              <header>
                <h3>getNode</h3>
                <h4>lunr.TokenStore.prototype.getNode()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>token - The token to get the node for.</li>
                  
                    <li>root - An optional node at which to start.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Retrieve a node from the token store for a given token.</p>

<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.TokenStore.prototype.getNode = function (token, root) {
  var root = root || this.root,
      key = token[0],
      rest = token.slice(1)

  if (!(key in root)) return {}

  if (rest.length === 0) {
    return root[key]
  } else {
    return this.getNode(rest, root[key])
  }
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='get'>
              <header>
                <h3>get</h3>
                <h4>lunr.TokenStore.prototype.get()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>token - The token to get the documents for.</li>
                  
                    <li>root - An optional node at which to start.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Retrieve the documents for a node for the given token.</p>

<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.TokenStore.prototype.get = function (token, root) {
  return this.getNode(token).docs || {}
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='remove'>
              <header>
                <h3>remove</h3>
                <h4>lunr.TokenStore.prototype.remove()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>token - The token to get the documents for.</li>
                  
                    <li>ref - The ref of the document to remove from this token.</li>
                  
                    <li>root - An optional node at which to start.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Remove the document identified by ref from the token in the store.</p>

<p>By default this function starts at the root of the current store, however it can start at any node of any token store if required.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.TokenStore.prototype.remove = function (token, ref, root) {
  var root = root || this.root,
      key = token[0],
      rest = token.slice(1)

  if (!(key in root)) return

  if (rest.length === 0) {
    delete root[key].docs[ref]
  } else {
    return this.remove(rest, ref, root[key])
  }
}</code></pre>
              </section>
              
            </section>
          
            <section class='method' id='expand'>
              <header>
                <h3>expand</h3>
                <h4>lunr.TokenStore.prototype.expand()</h4>
                <p class='type'>method</p>
                
                  <p class='related'>See: <a href='#'></a></p>
                
              </header>

              <section class='params'>
                
                  <h4>Params</h4>
                
                <ul>
                  
                    <li>token - The token to expand.</li>
                  
                </ul>
              </section>

              

              <section>
                <p>Find all the possible suffixes of the passed token using tokens currently in the store.</p>
              </section>

              <section class='source'>
                <h4>Source</h4>
                <pre><code>lunr.TokenStore.prototype.expand = function (token, memo) {
  var root = this.getNode(token),
      docs = root.docs || {},
      memo = memo || []

  if (Object.keys(docs).length) memo.push(token)

  Object.keys(root)
    .forEach(function (key) {
      if (key === 'docs') return

      memo.concat(this.expand(token + key, memo))
    }, this)

  return memo
}</code></pre>
              </section>
              
            </section>
          
        </article>
      
    </div>
  </div>
  <script>
    (function (hijs) {
    //
    // hijs - JavaScript Syntax Highlighter
    //
    // Copyright (c) 2010 Alexis Sellier
    //

    // All elements which match this will be syntax highlighted.
    var selector = hijs || 'code';

    var keywords = ('var function if else for while break switch case do new null in with void '
                   +'continue delete return this true false throw catch typeof with instanceof').split(' '),
        special  = ('eval window document undefined NaN Infinity parseInt parseFloat '
                   +'encodeURI decodeURI encodeURIComponent decodeURIComponent').split(' ');

    // Syntax definition
    // The key becomes the class name of the <span>
    // around the matched block of code.
    var syntax = [
      ['comment', /(\/\*(?:[^*\n]|\*+[^\/*])*\*+\/)/g],
      ['comment', /(\/\/[^\n]*)/g],
      ['string' , /("(?:(?!")[^\\\n]|\\.)*"|'(?:(?!')[^\\\n]|\\.)*')/g],
      ['regexp' , /(\/.+\/[mgi]*)(?!\s*\w)/g],
      ['class'  , /\b([A-Z][a-zA-Z]+)\b/g],
      ['number' , /\b([0-9]+(?:\.[0-9]+)?)\b/g],
      ['keyword', new(RegExp)('\\b(' + keywords.join('|') + ')\\b', 'g')],
      ['special', new(RegExp)('\\b(' + special.join('|') + ')\\b', 'g')]
    ];
    var nodes, table = {};

    if (/^[a-z]+$/.test(selector)) {
        nodes = document.getElementsByTagName(selector);
    } else if (/^\.[\w-]+$/.test(selector)) {
        nodes = document.getElementsByClassName(selector.slice(1));
    } else if (document.querySelectorAll) {
        nodes = document.querySelectorAll(selector);
    } else {
        nodes = [];
    }

    for (var i = 0, children; i < nodes.length; i++) {
        children = nodes[i].childNodes;

        for (var j = 0, str; j < children.length; j++) {
            code = children[j];

            if (code.length >= 0) { // It's a text node
                // Don't highlight command-line snippets
                if (! /^\$/.test(code.nodeValue.trim())) {
                    syntax.forEach(function (s) {
                        var k = s[0], v = s[1];
                        code.nodeValue = code.nodeValue.replace(v, function (_, m) {
                            return '\u00ab' + encode(k) + '\u00b7'
                                            + encode(m) +
                                   '\u00b7' + encode(k) + '\u00bb';
                        });
                    });
                }
            }
        }
    }
    for (var i = 0; i < nodes.length; i++) {
        nodes[i].innerHTML =
            nodes[i].innerHTML.replace(/\u00ab(.+?)\u00b7(.+?)\u00b7\1\u00bb/g, function (_, name, value) {
                value = value.replace(/\u00ab[^\u00b7]+\u00b7/g, '').replace(/\u00b7[^\u00bb]+\u00bb/g, '');
                return '<span class="' + decode(name) + '">' + escape(decode(value)) + '</span>';
        });
    }

    function escape(str) {
        return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // Encode ASCII characters to, and from Braille
    function encode (str, encoded) {
        table[encoded = str.split('').map(function (s) {
            if (s.charCodeAt(0) > 127) { return s }
            return String.fromCharCode(s.charCodeAt(0) + 0x2800);
        }).join('')] = str;
        return encoded;
    }
    function decode (str) {
        if (str in table) {
            return table[str];
        } else {
            return str.trim().split('').map(function (s) {
                if (s.charCodeAt(0) - 0x2800 > 127) { return s }
                return String.fromCharCode(s.charCodeAt(0) - 0x2800);
            }).join('');
        }
    }

    })(window.hijs);
  </script>
</body>
