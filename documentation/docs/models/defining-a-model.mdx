---
sidebar_position: 1
sidebar_label: Defining a Model
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Model Basics

In this tutorial you will learn what models are in Sequelize and how to use them.

## Concept

Models are the essence of Sequelize. A model is an abstraction that represents a table in your database.
In Sequelize, it is a class that extends [the `Model` class](pathname:///api/classes/Model.html).

The model tells Sequelize several things about the entity it represents, such as the name of the table in the database and which columns it has (and their data types).

A model in Sequelize has a name. This name does not have to be the same name of the table it represents in the database. Usually, models have singular names (such as `User`)
while tables have pluralized names (such as `users`), although this is fully configurable.

## Defining a Model

Models can be defined in two equivalent ways in Sequelize:

* Extending [Model](pathname:///api/classes/Model.html) and calling its [`init(attributes, options)`](pathname:///api/classes/Model.html#init) static method
* Calling [`sequelize.define(modelName, attributes, options)`](pathname:///api/classes/Sequelize.html#define)

To learn with an example, we will consider that we want to create a model to represent users, which have a `firstName` and a `lastName`. We want our model to be called `User`, and the table it represents is called `Users` in the database.

Both ways to define this model are shown below. After being defined, we can access our model with `sequelize.models.User`.

### Extending [Model](pathname:///api/classes/Model.html) (recommended)

<Tabs>
<TabItem value="ts" label="TypeScript">

Learn more about using Sequelize with TypeScript in [our TypeScript guide](../typescript.md).

```typescript
import { Sequelize, DataTypes, Model, InferAttributes, InferCreationAttributes, CreationOptional } from '@sequelize/core';

const sequelize = new Sequelize('sqlite::memory:');

class User extends Model<InferAttributes<User>, InferCreationAttributes<User>> {
  declare id: CreationOptional<number>,
  declare firstName: string,
  declare lastName: string | null,
}

User.init({
  // Model attributes are defined here
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true,
  },
  firstName: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  lastName: {
    type: DataTypes.STRING,
    // allowNull defaults to true, except for primary keys
  },
}, {
  // Other model options go here
  sequelize, // We need to pass the connection instance
});

// Once init has been called, the model also becomes available through sequelize.models
console.log(User === sequelize.models.User); // true
```

</TabItem>
<TabItem value="js" label="JavaScript (CJS)">

```javascript
const { Sequelize, DataTypes, Model } = require('@sequelize/core');
const sequelize = new Sequelize('sqlite::memory:');

class User extends Model {}

User.init({
  // Model attributes are defined here
  firstName: {
    type: DataTypes.STRING,
    allowNull: false,
  },
  lastName: {
    type: DataTypes.STRING,
    // allowNull defaults to true, except for primary keys
  },
}, {
  // Other model options go here
  sequelize, // We need to pass the connection instance
});

// Once init has been called, the model also becomes available through sequelize.models
console.log(User === sequelize.models.User); // true
```

</TabItem>
</Tabs>

:::caution Model Names & Minification

When defining a model using the class-based approach, the name of the model will, by default, be the name of your class.
In the above example, the name of the model is `User`.

If you minify your code, it is possible that the class' name — and therefore its model name — will be changed by your minifier.
This can be an issue, as many systems use your modelName, from [Sequelize#models](pathname:///api/classes/Sequelize.html#models)
to [the name of your Database table name](./sql-name-inference.mdx).

The solution to prevent this issue is to explicitly set the `modelName` option:

```typescript
class User extends Model {}

User.init({ /* attributes */ }, {
  /* other model options */

  // by specifying 'modelName' explicitely, the name of this model can be safely minified.
  modelName: 'User',
});
```

:::

#### Caveat with Public Class Fields

Adding a [Public Class Field](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields) with the same name as one of the model's attribute is going to cause issues.
Sequelize adds a getter & a setter for each attribute defined through `Model.init`.
Adding a Public Class Field will shadow those getter and setters, blocking access to the model's actual data.

This is an issue we're working on. [Head to this issue for more information](https://github.com/sequelize/meetings/issues/16).

```typescript
// Invalid
class User extends Model {
  id; // this field will shadow sequelize's getter & setter. It should be removed.
  otherPublicField; // this field does not shadow anything. It is fine.
}

User.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true
  }
}, { sequelize });

const user = new User({ id: 1 });
user.id; // undefined
```

```typescript
// Valid
class User extends Model {
  otherPublicField;
}

User.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true
  }
}, { sequelize });

const user = new User({ id: 1 });
user.id; // 1
```

In TypeScript, you can add typing information without adding an actual public class field by using the `declare` keyword:

```typescript
// Valid
class User extends Model {
  declare id: number; // this is ok! The 'declare' keyword ensures this field will not be emitted by TypeScript.
}

User.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true
  }
}, { sequelize });

const user = new User({ id: 1 });
user.id; // 1
```

### Using [`sequelize.define`](pathname:///api/classes/Sequelize.html#define)

Internally, `sequelize.define` calls `Model.init`, so both approaches are essentially equivalent.

```js
const { Sequelize, DataTypes } = require('@sequelize/core');
const sequelize = new Sequelize('sqlite::memory:');

const User = sequelize.define('User', {
  // Model attributes are defined here
  firstName: {
    type: DataTypes.STRING,
    allowNull: false
  },
  lastName: {
    type: DataTypes.STRING
    // allowNull defaults to true, except for primary keys
  }
}, {
  // Other model options go here
});

// The model is also available through sequelize.models
console.log(User === sequelize.models.User); // true
```

## Column declaration shorthand syntax

If the only thing being specified about a column is its data type, the syntax can be shortened:

```js
// This:
sequelize.define('User', {
  // name is a nullable string
  name: DataTypes.STRING,
});

// Is equivalent to this:
sequelize.define('User', {
  name: {
    type: DataTypes.STRING,
  },
});
```

## Default Values

By default, Sequelize assumes that the default value of a column is `NULL`. This behavior can be changed by passing a specific `defaultValue` to the column definition:

```js
sequelize.define('User', {
  name: {
    type: DataTypes.STRING,
    defaultValue: "John Doe"
  }
});
```

Some special values, such as `DataTypes.NOW`, are also accepted:

```js
sequelize.define('Foo', {
  bar: {
    type: DataTypes.DATETIME,
    defaultValue: DataTypes.NOW
    // This way, the current date/time will be used to populate this column (at the moment of insertion)
  }
});
```

## Column Data Types

Every attribute you define in your model must have a data type.
e.g. an attribute with a type `DataTypes.INTEGER` will result in a column of type `integer`.

[The list of supported Data Types is available here](./datatypes.md).

## Column Options

When defining a column, apart from specifying the `type` of the column, and the `allowNull` and `defaultValue` options mentioned above, there are a lot more options that can be used. Some examples are below.

```js
const { Model, DataTypes, Deferrable } = require('@sequelize/core');

class Foo extends Model {}
Foo.init({
  // instantiating will automatically set the flag to true if not set
  flag: { type: DataTypes.BOOLEAN, allowNull: false, defaultValue: true },

  // default values for dates => current time
  myDate: { type: DataTypes.DATE, defaultValue: DataTypes.NOW },

  // setting allowNull to false will add NOT NULL to the column, which means an error will be
  // thrown from the DB when the query is executed if the column is null. If you want to check that a value
  // is not null before querying the DB, look at the validations section below.
  title: { type: DataTypes.STRING, allowNull: false },

  // Creating two objects with the same value will throw an error. The unique property can be either a
  // boolean, or a string. If you provide the same string for multiple columns, they will form a
  // composite unique key.
  uniqueOne: { type: DataTypes.STRING,  unique: 'compositeIndex' },
  uniqueTwo: { type: DataTypes.INTEGER, unique: 'compositeIndex' },

  // The unique property is simply a shorthand to create a unique constraint.
  someUnique: { type: DataTypes.STRING, unique: true },

  // Go on reading for further information about primary keys
  identifier: { type: DataTypes.STRING, primaryKey: true },

  // autoIncrement can be used to create auto_incrementing integer columns
  incrementMe: { type: DataTypes.INTEGER, autoIncrement: true },

  // You can specify a custom column name via the 'field' attribute:
  fieldWithUnderscores: { type: DataTypes.STRING, field: 'field_with_underscores' },

  // It is possible to create foreign keys:
  bar_id: {
    type: DataTypes.INTEGER,

    references: {
      // This is a reference to another model
      model: Bar,

      // This is the column name of the referenced model
      key: 'id',

      // With PostgreSQL, it is optionally possible to declare when to check the foreign key constraint, passing the Deferrable type.
      deferrable: Deferrable.INITIALLY_IMMEDIATE
      // Options:
      // - `Deferrable.INITIALLY_IMMEDIATE` - Immediately check the foreign key constraints
      // - `Deferrable.INITIALLY_DEFERRED` - Defer all foreign key constraint check to the end of a transaction
      // - `Deferrable.NOT` - Don't defer the checks at all (default) - This won't allow you to dynamically change the rule in a transaction
    }
  },

  // Comments can only be added to columns in MySQL, MariaDB, PostgreSQL and MSSQL
  commentMe: {
    type: DataTypes.INTEGER,
    comment: 'This is a column name that has a comment'
  }
}, {
  sequelize,

  // Using `unique: true` in an attribute above is exactly the same as creating the index in the model's options:
  indexes: [{ unique: true, fields: ['someUnique'] }]
});
```

## Model Methods

Sequelize models are [classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes).
You can very easily add custom instance or class level methods.

:::info

`Model` provides a suite of built-in static & instance methods that can be used to interact with the database.

[Take a look at the API Reference for `Model`](pathname:///api/classes/Model.html) for more information

:::

<Tabs>
<TabItem value="ts" label="TypeScript">

```typescript
import { InferCreationAttributes, InferAttributes, Model } from '@sequelize/core';

class User extends Model<InferAttributes<User>, InferCreationAttributes<User>> {
  declare firstname: string | null;
  declare lastname: string | null;

  instanceLevelMethod() {
    return 'bar';
  }

  getFullname() {
    return [this.firstname, this.lastname].join(' ');
  }

  static classLevelMethod() {
    return 'foo';
  }
}

User.init({
  firstname: Sequelize.TEXT,
  lastname: Sequelize.TEXT
}, { sequelize });

console.log(User.classLevelMethod()); // 'foo'
const user = User.build({ firstname: 'Jane', lastname: 'Doe' });
console.log(user.instanceLevelMethod()); // 'bar'
console.log(user.getFullname()); // 'Jane Doe'
```

</TabItem>
<TabItem value="js" label="JavaScript">

```typescript
import { Model } from '@sequelize/core';

class User extends Model {
  instanceLevelMethod() {
    return 'bar';
  }

  getFullname() {
    return [this.firstname, this.lastname].join(' ');
  }

  static classLevelMethod() {
    return 'foo';
  }
}

User.init({
  firstname: Sequelize.TEXT,
  lastname: Sequelize.TEXT
}, { sequelize });

console.log(User.classLevelMethod()); // 'foo'
const user = User.build({ firstname: 'Jane', lastname: 'Doe' });
console.log(user.instanceLevelMethod()); // 'bar'
console.log(user.getFullname()); // 'Jane Doe'
```

</TabItem>
</Tabs>
