'use strict';

/* jshint -W110 */
var Utils = require('../../utils')
  , DataTypes = require('../../data-types')
  , Transaction = require('../../transaction')
  , _ = require('lodash');

var sysschemas = "\'SYS\', \'SYSTEM\', \'OUTLN\', \'CSMIG\', \'CTXSYS\', \'DBSNMP\', \'DIP\', \'DMSYS\', \'DSSYS\', \'EXFSYS\', \'LBACSYS\', \'MDSYS\', \'ORACLE_OCM\', \'PERFSTAT\', \'TRACESVR\', \'TSMSYS\', \'XDB\',\'MDDATA\',\'SPATIAL_WFS_ADMIN_USR\',\'SPATIAL_CSW_ADMIN_USR\',\'APEX_PUBLIC_USER\',\'APPQOSSYS\',\'WMSYS\',\'ANONYMOUS\',\'OLAPSYS\',\'ORDSYS\',\'ORDDATA\',\'ORDPLUGINS\',\'SI_INFORMTN_SCHEMA\',\'SYSMAN\',\'FLOWS_FILES\',\'APEX_030200\',\'OWBSYS\',\'OWBSYS_AUDIT\',\'MGMT_VIEW\'";

var OracleQueryGenerator = _.extend(
  _.clone(require('../abstract/query-generator'))
);

var QueryGenerator = {
  options: {},
  dialect: 'oracle',

  createSchema: function(schema) {
    return [
        'DECLARE',
        '  V_COUNT INTEGER;',
        '  V_CURSOR_NAME INTEGER;',
        '  V_RET INTEGER;',
        'BEGIN',
        '  SELECT COUNT(1) INTO V_COUNT FROM ALL_USERS WHERE USERNAME = ', wrapSingleQuote(schema),';',
        '  IF V_COUNT = 0 THEN',
        '    EXECUTE IMMEDIATE', wrapSingleQuote('CREATE USER ' + this.quoteIdentifier(schema) + ' IDENTIFIED BY 12345'), ';',
        '    EXECUTE IMMEDIATE', wrapSingleQuote('GRANT create session TO ' + this.quoteIdentifier(schema)), ';',
        '    EXECUTE IMMEDIATE', wrapSingleQuote('GRANT create table TO ' + this.quoteIdentifier(schema)), ';',
        '    EXECUTE IMMEDIATE', wrapSingleQuote('GRANT create view TO ' + this.quoteIdentifier(schema)), ';',
        '    EXECUTE IMMEDIATE', wrapSingleQuote('GRANT create any trigger TO ' + this.quoteIdentifier(schema)), ';',
        '    EXECUTE IMMEDIATE', wrapSingleQuote('GRANT create any procedure TO ' + this.quoteIdentifier(schema)), ';',
        '    EXECUTE IMMEDIATE', wrapSingleQuote('GRANT create sequence TO ' + this.quoteIdentifier(schema)), ';',
        '    EXECUTE IMMEDIATE', wrapSingleQuote('GRANT create synonym TO ' + this.quoteIdentifier(schema)), ';',
        '    EXECUTE IMMEDIATE', wrapSingleQuote('GRANT UNLIMITED TABLESPACE TO ' + this.quoteIdentifier(schema)), ';',
        '  END IF;',
        'END;',
    ].join(' ');
  },

  showSchemasQuery: function() {
    return 'SELECT USERNAME AS "schema_name" FROM ALL_USERS WHERE USERNAME NOT IN (' + sysschemas + ', user)';
  },

  dropSchema: function(schema, options) {
    return _.template("DROP USER <%= schema %> CASCADE")({
      schema: this.quoteTable(schema)
    });
  },

  versionQuery: function() {
    return 'SELECT VERSION FROM PRODUCT_COMPONENT_VERSION GROUP BY VERSION';
  },

  dropTableQuery: function(tableName, options) {
    options = options || {};

    var query = [
        'DECLARE',
          'V_COUNT INTEGER;',
          'V_CURSOR_NAME INTEGER;',
          'V_RET INTEGER;',
        'BEGIN',
          'SELECT COUNT(1) INTO V_COUNT FROM ALL_TABLES WHERE TABLE_NAME = <%= tablestr %> AND OWNER = <%= ownerstr %>;',
          'IF V_COUNT = 1 THEN',
            'V_CURSOR_NAME := DBMS_SQL.OPEN_CURSOR;',
            'DBMS_SQL.PARSE(V_CURSOR_NAME, \'DROP TABLE <%= table %> CASCADE CONSTRAINTS\', DBMS_SQL.NATIVE);',
            'V_RET := DBMS_SQL.EXECUTE(V_CURSOR_NAME);',
          'END IF;',
        'END;',
    ].join(' ');

    var strTable = tableName;
    var strOwner = 'USER';
    if (tableName.tableName) {
      strTable = tableName.tableName;
      strOwner = wrapSingleQuote(tableName.schema);
    }

    return _.template(query)({
      table: this.quoteTable(tableName),
      tablestr: wrapSingleQuote(strTable),
      ownerstr: strOwner
    });
  },

  // Sends auto increment field to query-interface function. That means that it should do more queries to create trigger and sequence
  // For 12.1 version you can return null and then change createTableQuery to not remove IDENTITY attribute for that version.
  checkTableAutoinc: function(tableName, attributes) {
    for (var attr in attributes) {
      var dataType = attributes[attr];
      if (Utils._.includes(dataType, 'GENERATED BY DEFAULT AS IDENTITY')) {
        return attr;
      }
    }
    return null;
  },

  createTableQuery: function(tableName, attributes, options) {
    var query = 'CREATE TABLE <%= table %> (<%= attributes%>)'
      , attrStr = []
      , primaryKeys = [];

    for (var attr in attributes) {
      var dataType = attributes[attr];
      if (Utils._.includes(dataType, 'PRIMARY KEY')) {
        primaryKeys.push(attr);
        dataType = dataType.replace(/ GENERATED BY DEFAULT AS IDENTITY/, '');
        attrStr.push(this.quoteIdentifier(attr) + ' ' + dataType.replace(/ PRIMARY KEY/, ''));
      } else {
        attrStr.push(this.quoteIdentifier(attr) + ' ' + dataType);
      }
    }

    var values = {
      table: this.quoteTable(tableName),
      attributes: attrStr.join(', '),
    },
    pkString = primaryKeys.map(function(pk) { return this.quoteIdentifier(pk); }.bind(this)).join(', ');
    if (pkString.length > 0) {
      values.attributes += ', PRIMARY KEY (' + pkString + ')';
    }

    var sql = _.template(query)(values).trim();
    return this.replaceBooleanDefaults(sql);
  },

  booleanValue: function(value){
    return !!value ? 1 : 0;
  },

  addWhereLimitAndOffset: function(options){
    if (options.offset && !options.limit) {
    } else if (options.limit) {
      if (options.offset) {
      } else {
        options.where.ROWNUM = {$lte: options.limit};
      }
    }
    return options;
  },

  addLimitAndOffset: function(options){
    var fragment = '';
    if (options.offset && !options.limit) {
      // fragment += ' LIMIT ' + options.offset + ', ' + 10000000000000;
    } else if (options.limit) {
      if (options.offset) {
        // fragment += ' LIMIT ' + options.offset + ', ' + options.limit;
      } else {
        // fragment += ' LIMIT ' + options.limit;
      }
    }

    return fragment;
  },

  addColumnQuery: function(table, key, dataType) {
    var query = 'ALTER TABLE <%= table %> ADD <%= attribute %>;'
      , attributes = {};

    attributes[key] = dataType;
    var fields = this.attributesToSQL(attributes, {
      context: 'addColumn'
    });
    var attribute = _.template('<%= key %> <%= definition %>')({
        key: this.quoteIdentifier(key),
        definition: fields[key]
      });

    var sql =  _.template(query)({
      table: this.quoteTable(table),
      attribute: attribute
    });

    return this.replaceBooleanDefaults(sql);
  },

  showTablesQuery: function() {
    return "SELECT TABLE_NAME AS table_name FROM ALL_TABLES WHERE OWNER NOT IN (" + sysschemas + ")";
  },

  upsertQuery: function (tableName, insertValues, updateValues, where, rawAttributes, options) {
    options.ignore = true;
    var sql = this.insertQuery(tableName, insertValues, rawAttributes, options) + ' ' + this.updateQuery(tableName, updateValues, where, options, rawAttributes);

    return sql;
  },

  bulkInsertQuery: function(tableName, attrValueHashes, options, modelAttributes) {
    var query = 'INSERT ALL <%= tuples %> SELECT 1 FROM DUAL'
      , tuples = ''
      , allAttributes = [];
    _.forEach(attrValueHashes, function(attrValueHash) {
      _.forOwn(attrValueHash, function(value, key) {
        if (allAttributes.indexOf(key) === -1) allAttributes.push(key);
      });
    });

    _.forEach(attrValueHashes, function(attrValueHash) {
      tuples += (' INTO ' + this.quoteTable(tableName) + ' (' +
        allAttributes.map(function(attr) {
          return this.quoteIdentifier(attr);
        }.bind(this)).join(',') +
      ') VALUES (' +
        allAttributes.map(function (key) {
          return this.escape(attrValueHash[key], modelAttributes && modelAttributes[key]);
        }.bind(this)).join(',') +
      ')');
    }.bind(this));

    var replacements  = {
      tuples: tuples
    };

    return _.template(query)(replacements);
  },

  updateQuery: function(tableName, attrValueHash, where, options, modelAttributes) {
    options = options || {};
    _.defaults(options, this.options);

    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);

    var query  = 'UPDATE <%= table %> SET <%= values %> <%= where %>'
      , values = [];

    for (var key in attrValueHash) {
      values.push(this.quoteIdentifier(key) + '=' + this.escape(attrValueHash[key], modelAttributes && modelAttributes[key]));
    }

    var replacements = {
      table: this.quoteTable(tableName),
      values: values.join(','),
      where: this.whereQuery(where)
    };

    return _.template(query)(replacements).trim();
  },

  deleteQuery: function(tableName, where, options) {
    options = options || {};

    var query = 'DELETE FROM <%= table %><%= where %>';
    var replacements = {
      table: this.quoteTable(tableName),
      where: this.getWhereConditions(where)
    };

    if (replacements.where) {
      replacements.where = ' WHERE ' + replacements.where;
    }

    return _.template(query)(replacements);
  },

  attributesToSQL: function(attributes) {
    var result = {};

    for (var name in attributes) {
      var dataType = attributes[name];
      var fieldName = dataType.field || name;

      if (_.isObject(dataType)) {
        var template     = '<%= type %>'
          , replacements = { type: dataType.type };

        if (dataType.type instanceof DataTypes.ENUM) {
          replacements.type = 'VARCHAR2(255)';

          if (!(Array.isArray(dataType.values) && (dataType.values.length > 0))) {
            throw new Error("Values for ENUM haven't been defined.");
          }

          template += ' CHECK (' + this.quoteIdentifier(fieldName) + ' IN(' + _.map(dataType.values, function(value) {
            return this.escape(value);
          }.bind(this)).join(', ') + '))';
        }

        if (dataType.hasOwnProperty('allowNull') && !dataType.allowNull) {
          template += ' NOT NULL';
        }

        if (Utils.defaultValueSchemable(dataType.defaultValue)) {
          // TODO thoroughly check that DataTypes.NOW will properly
          // get populated on all databases as DEFAULT value
          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP
          template += ' DEFAULT <%= defaultValue %>';
          replacements.defaultValue = this.escape(dataType.defaultValue);
        }

        if (dataType.unique === true) {
          template += ' UNIQUE';
        }

        if (dataType.primaryKey) {
          template += ' PRIMARY KEY';

          if (dataType.autoIncrement) {
            template += '  GENERATED BY DEFAULT AS IDENTITY';
          }
        }

        if(dataType.references) {
          dataType = Utils.formatReferences(dataType);
          template += ' REFERENCES <%= referencesTable %> (<%= referencesKey %>)';
          replacements.referencesTable = this.quoteTable(dataType.references.model);

          if(dataType.references.key) {
            replacements.referencesKey = this.quoteIdentifier(dataType.references.key);
          } else {
            replacements.referencesKey = this.quoteIdentifier('id');
          }

          if(dataType.onDelete) {
            template += ' ON DELETE <%= onDeleteAction %>';
            replacements.onDeleteAction = dataType.onDelete.toUpperCase();
          }

          // Oracle does not support ON UPDATE
          // if(dataType.onUpdate) {
          //   template += ' ON UPDATE <%= onUpdateAction %>';
          //   replacements.onUpdateAction = dataType.onUpdate.toUpperCase();
          // }

        }

        result[fieldName] = _.template(template)(replacements);
      } else {
        result[fieldName] = dataType;
      }
    }

    return result;
  },

  findAutoIncrementField: function(factory) {
    var fields = [];

    for (var name in factory.attributes) {
      if (factory.attributes.hasOwnProperty(name)) {
        var definition = factory.attributes[name];
        if (definition && definition.autoIncrement) {
          fields.push(name);
        }
      }
    }

    return fields;
  },

  showIndexesQuery: function(tableName) {
    return 'SELECT INDEX_NAME FROM USER_INDEXES WHERE TABLE_NAME = ' + wrapSingleQuote(tableName);
  },

  removeIndexQuery: function(tableName, indexNameOrAttributes) {
    var sql = 'DROP INDEX IF EXISTS <%= indexName %>'
      , indexName = indexNameOrAttributes;

    if (typeof indexName !== 'string') {
      indexName = Utils.inflection.underscore(tableName + '_' + indexNameOrAttributes.join('_'));
    }

    return _.template(sql)( { tableName: this.quoteIdentifiers(tableName), indexName: indexName });
  },

  describeTableQuery: function(tableName, schema, schemaDelimiter) {
    var options = {};
    options.schema = schema;
    options.schemaDelimiter = schemaDelimiter;
    options.quoted = false;

    var sql = 'PRAGMA TABLE_INFO(<%= tableName %>);';
    return _.template(sql)({ tableName: this.addSchema({tableName: this.quoteIdentifiers(tableName), options: options})});
  },

  removeColumnQuery: function(tableName, attributeName) {
    var query = 'ALTER TABLE <%= tableName %> DROP COLUMN <%= attributeName %>;';
    return _.template(query)({
      tableName: this.quoteTable(tableName),
      attributeName: this.quoteIdentifier(attributeName)
    });
  },

  renameColumnQuery: function(tableName, attrBefore, attributes) {
    var query = 'ALTER TABLE <%= tableName %> RENAME COLUMN <%= attributes %>;';
    var attrString = [];

    for (var attributeName in attributes) {
      attrString.push(_.template('<%= before %> TO <%= after %>')({
        before: this.quoteIdentifier(attrBefore),
        after: this.quoteIdentifier(attributeName)
      }));
    }

    return _.template(query)({
      tableName: this.quoteTable(tableName),
      attributes: attrString.join(', ')
    });
  },

  dropSequence: function(tableName, autoincField) {
    var sql = [
      'DECLARE',
      '  V_COUNT INTEGER;',
        'V_CURSOR_NAME INTEGER;',
        'V_RET INTEGER;',
      'BEGIN',
        'SELECT COUNT(1) INTO V_COUNT FROM ALL_SEQUENCES WHERE SEQUENCE_NAME = <%= sequenceSQName %> AND SEQUENCE_OWNER = <%= sequenceSQOwner %>;',
        'IF V_COUNT = 1 THEN',
          'V_CURSOR_NAME := DBMS_SQL.OPEN_CURSOR;',
          'DBMS_SQL.PARSE(V_CURSOR_NAME, \'DROP SEQUENCE <%= sequenceName %>\', DBMS_SQL.NATIVE);',
          'V_RET := DBMS_SQL.EXECUTE(V_CURSOR_NAME);',
        'END IF;',
      'END;',
    ].join('\n\t');

    var seqstr = tableName;
    var ownerstr = 'USER';
    if (tableName.tableName) {
      seqstr = tableName.tableName;
      ownerstr = wrapSingleQuote(tableName.schema);
    }

    return Utils._.template(sql)({
      sequenceName: this.generateSequenceName(tableName, autoincField),
      sequenceSQName: wrapSingleQuote(seqstr + '_' + autoincField + '_PK_SEQUENCE'),
      sequenceSQOwner: ownerstr
    });
  },

  createSequence: function(tableName, autoincField, initValue) {
    var sql = [
      'CREATE SEQUENCE <%= sequenceName %>  START WITH ' + initValue + ' INCREMENT BY 1',
    ].join('\n\t');

    return Utils._.template(sql)({
      sequenceName: this.generateSequenceName(tableName, autoincField),
      initValue: initValue,
    });
  },

  generateTriggerName: function(tableName, autoincField) {
    if (tableName.tableName) {
      tableName.tableName = tableName.tableName + '_' + autoincField + '_PK_TRIGGER';
    } else {
      tableName = tableName + '_' + autoincField + '_PK_TRIGGER';
    }
    return this.quoteTable(tableName);
  },

  generateSequenceName: function(tableName, autoincField) {
    if (tableName.tableName) {
      tableName.tableName = tableName.tableName + '_' + autoincField + '_PK_SEQUENCE';
    } else {
      tableName = tableName + '_' + autoincField + '_PK_SEQUENCE';
    }
    return this.quoteTable(tableName);
  },

  createPKTrigger: function(tableName, autoincfield) {
    var sql = [
      'CREATE OR REPLACE TRIGGER <%= triggerName %>',
      'BEFORE INSERT ON <%= tableName %>',
      'REFERENCING NEW AS New',
      'FOR EACH ROW',
      'DECLARE',
      '  max_id NUMBER;',
      '  cur_seq NUMBER;',
      'BEGIN',
      '    IF :NEW.<%= fieldName %> is null then',
      '        SELECT <%= sequenceName %>.nextval INTO :NEW.<%= fieldName %> FROM dual;',
      '    ELSE',
      '        SELECT greatest(nvl(max(<%= fieldName %>),0), :NEW.<%= fieldName %>) INTO max_id FROM <%= tableName %>;',
      '        SELECT <%= sequenceName %>.nextval INTO cur_seq FROM dual;',
      '        WHILE cur_seq < max_id',
      '        LOOP',
      '            SELECT <%= sequenceName %>.nextval INTO cur_seq FROM dual;',
      '        END LOOP;',
      '    END IF;',
      'END;',
    ].join('\n\t');

    return _.template(sql)({
      tableName: this.quoteTable(tableName),
      triggerName: this.generateTriggerName(tableName, autoincfield),
      sequenceName: this.generateSequenceName(tableName, autoincfield),
      fieldName: this.quoteIdentifier(autoincfield),
    });
  },

  commitTransactionQuery: function(options) {
    return 'COMMIT;';
  },

  rollbackTransactionQuery: function(transaction, options) {
    return 'ROLLBACK;';
  },

  startTransactionQuery: function(transaction, options) {
    if (options.parent) {
      return 'SAVEPOINT ' + wrapSingleQuote(transaction.name);
    }

    return 'SET TRANSACTION NAME ' + wrapSingleQuote(transaction.name);
  },

  setAutocommitQuery: function(value) {
    return 'SET AUTOCOMMIT ' + (!!value ? 'OFF' : 'ON');
  },

  setIsolationLevelQuery: function(value) {
    switch (value) {
      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:
        return '';
      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:
        return '';
      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:
        return 'READ COMMITTED';
      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:
        return "SERIALIZABLE";
      default:
        throw new Error('Unknown isolation level: ' + value);
    }
  },

  replaceBooleanDefaults: function(sql) {
    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');
  },

  quoteIdentifier: function(identifier) {
    if (identifier === '*') return identifier;
    return Utils.addTicks(identifier, '"');
  },

      /**
   * Generates an SQL query that returns all foreign keys of a table.
   *
   * @param  {String} tableName  The name of the table.
   * @param  {String} schemaName The name of the schema.
   * @return {String}            The generated sql query.
   */
  getForeignKeysQuery: function(tableName, schemaName) {
    var sql = 'select constraint_name as "constraint_name" from user_constraints where table_name = <%= tableName %>';

    return _.template(sql)({ tableName: wrapSingleQuote(tableName) });
  },

  dropForeignKeyQuery: function(tableName, foreignKey) {
    var sql = [
      'DECLARE',
      '  V_COUNT INTEGER;',
      '  V_CURSOR_NAME INTEGER;',
      '  V_RET INTEGER;',
      'BEGIN',
      '  SELECT COUNT(1) INTO V_COUNT FROM user_constraints WHERE table_name = \'<%= tableName %>\' AND CONSTRAINT_NAME = \'<%= foreignKey %>\';',
      '  IF V_COUNT = 1 THEN',
      '    V_CURSOR_NAME := DBMS_SQL.OPEN_CURSOR;',
      '    DBMS_SQL.PARSE(V_CURSOR_NAME, \'ALTER TABLE "<%= tableName %>" DROP CONSTRAINT "<%= foreignKey %>" CASCADE\', DBMS_SQL.NATIVE);',
      '    V_RET := DBMS_SQL.EXECUTE(V_CURSOR_NAME);',
      '  END IF;',
      'END;',
    ].join('\n\t');

    return _.template(sql)({ tableName: tableName, foreignKey: foreignKey });
  }
};

// private methods
function wrapSingleQuote(identifier){
  return Utils.addTicks(identifier, "'");
}

module.exports = _.extend({}, OracleQueryGenerator, QueryGenerator);
