import type { AbstractDialect } from './dialects/abstract';
import type { AbstractConnectionManager } from './dialects/abstract/connection-manager';
import type { QueryInterface, ColumnsDescription } from './dialects/abstract/query-interface';
import type { HookReturn, SequelizeHooks } from './hooks';
import { Hooks } from './hooks';
import type { ValidationOptions } from './instance-validator';
import type {
  BulkCreateOptions,
  CreateOptions,
  DestroyOptions,
  DropOptions,
  FindOptions,
  InstanceDestroyOptions,
  Logging,
  Model,
  ModelAttributeColumnOptions,
  ModelAttributes,
  ModelOptions,
  UpdateOptions,
  WhereOperators,
  Hookable,
  ModelStatic,
  CreationAttributes,
  Attributes,
  ColumnReference,
  Transactionable,
  Poolable,
  WhereAttributeHashValue,
} from './model';
import type { ModelManager } from './model-manager';
import type { Cast, Col, DeepWriteable, Fn, Json, Literal, Where } from './utils';
import type { QueryTypes, Transaction, TransactionOptions, TRANSACTION_TYPES, ISOLATION_LEVELS, PartlyRequired, Op, DataTypes } from '.';

/**
 * Additional options for table altering during sync
 */
export interface SyncAlterOptions {
  /**
   * Prevents any drop statements while altering a table when set to `false`
   */
  drop?: boolean;
}

/**
 * Sync Options
 */
export interface SyncOptions extends Logging, Hookable {
  /**
   * If force is true, each DAO will do DROP TABLE IF EXISTS ..., before it tries to create its own table
   */
  force?: boolean;

  /**
   * If alter is true, each DAO will do ALTER TABLE ... CHANGE ...
   * Alters tables to fit models. Provide an object for additional configuration. Not recommended for production use. If not further configured deletes data in columns that were removed or had their type changed in the model.
   */
  alter?: boolean | SyncAlterOptions;

  /**
   * Match a regex against the database name before syncing, a safety check for cases where force: true is
   * used in tests but not live code
   */
  match?: RegExp;

  /**
   * The schema that the tables should be created in. This can be overridden for each table in sequelize.define
   */
  schema?: string;

  /**
   * An optional parameter to specify the schema search_path (Postgres only)
   */
  searchPath?: string;
}

export interface DefaultSetOptions { }

/**
 * Connection Pool options.
 *
 * Used in {@link Options.pool}
 */
export interface PoolOptions {
  /**
   * Maximum number of connections in pool. Default is 5
   */
  max?: number;

  /**
   * Minimum number of connections in pool. Default is 0
   */
  min?: number;

  /**
   * The maximum time, in milliseconds, that a connection can be idle before being released
   */
  idle?: number;

  /**
   * The maximum time, in milliseconds, that pool will try to get connection before throwing error
   */
  acquire?: number;

  /**
   * The time interval, in milliseconds, after which sequelize-pool will remove idle connections.
   */
  evict?: number;

  /**
   * The number of times to use a connection before closing and replacing it.  Default is Infinity
   */
  maxUses?: number;

  /**
   * A function that validates a connection. Called with client. The default function checks that client is an
   * object, and that its state is not disconnected
   */
  validate?(client?: unknown): boolean;
}

export type NormalizedPoolOptions = Readonly<Required<PoolOptions>>;

export interface ConnectionOptions {
  host?: string;
  port?: string | number;
  username?: string;
  password?: string;
  database?: string;
  protocol?: string;
  ssl?: boolean;
  dialectOptions?: DialectOptions;
}

/**
 * Interface for replication Options in the sequelize constructor
 */
export interface ReplicationOptions {
  read: Array<ConnectionOptions | string>;

  write: ConnectionOptions | string;
}

export interface NormalizedReplicationOptions {
  read: ConnectionOptions[];

  write: ConnectionOptions;
}

/**
 * Used to map operators to their Symbol representations
 */
export interface OperatorsAliases {
  [K: string]: symbol;
}

/**
 * Final config options generated by sequelize.
 */
export interface Config {
  readonly database: string;
  readonly dialectModule?: object;
  readonly host?: string;
  readonly port: number;
  readonly username: string;
  readonly password: string | null;
  readonly pool: NormalizedPoolOptions;
  readonly protocol: 'tcp';
  readonly native: boolean;
  readonly ssl: boolean;
  readonly replication: NormalizedReplicationOptions;
  readonly dialectModulePath: null | string;
  readonly keepDefaultTimezone?: boolean;
  readonly dialectOptions: Readonly<DialectOptions>;
}

export type Dialect = 'mysql' | 'postgres' | 'sqlite' | 'mariadb' | 'mssql' | 'db2' | 'snowflake' | 'ibmi';

export interface RetryOptions {
  match?: Array<RegExp | string | Function>;
  max?: number;
}

/**
 * Options for the constructor of the {@link Sequelize} main class.
 */
export interface Options extends Logging {
  /**
   * The dialect of the database you are connecting to. One of mysql, postgres, sqlite, mariadb and mssql.
   *
   * @default 'mysql'
   */
  dialect?: Dialect;

  /**
   * If specified, will use the provided module as the dialect.
   *
   * @example
   * `dialectModule: require('@myorg/tedious'),`
   */
  dialectModule?: object;

  /**
   * If specified, load the dialect library from this path. For example, if you want to use pg.js instead of
   * pg when connecting to a pg database, you should specify 'pg.js' here
   */
  dialectModulePath?: string;

  /**
   * An object of additional options, which are passed directly to the connection library
   */
  dialectOptions?: DialectOptions;

  /**
   * Only used by sqlite.
   *
   * @default ':memory:'
   */
  storage?: string;

  /**
   * The name of the database
   */
  database?: string;

  /**
   * The username which is used to authenticate against the database.
   */
  username?: string;

  /**
   * The password which is used to authenticate against the database.
   */
  password?: string;

  /**
   * The host of the relational database.
   *
   * @default 'localhost'
   */
  host?: string;

  /**
   * The port of the relational database.
   */
  port?: number | string;

  /**
   * A flag that defines if is used SSL.
   */
  ssl?: boolean;

  /**
   * The protocol of the relational database.
   *
   * @default 'tcp'
   */
  protocol?: string;

  /**
   * The version of the Database Sequelize will connect to.
   * If unspecified, or set to 0, Sequelize will retrieve it during its first connection to the Database.
   */
  databaseVersion?: string | number;

  /**
   * Default options for model definitions. See Model.init.
   */
  define?: ModelOptions;

  /**
   * Default options for sequelize.query
   */
  query?: QueryOptions;

  /**
   * Default options for sequelize.set
   */
  set?: DefaultSetOptions;

  /**
   * Default options for sequelize.sync
   */
  sync?: SyncOptions;

  /**
   * The timezone used when converting a date from the database into a JavaScript date. The timezone is also
   * used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP
   * and other time related functions have in the right timezone. For best cross platform performance use the
   * format
   * +/-HH:MM. Will also accept string versions of timezones supported by Intl.Locale (e.g. 'America/Los_Angeles');
   * this is useful to capture daylight savings time changes.
   *
   * @default '+00:00'
   */
  timezone?: string;

  /**
   * A flag that defines if the default timezone is used to convert dates from the database.
   *
   * @default false
   */
  keepDefaultTimezone?: boolean;

  /**
   * A flag that defines if null values should be passed to SQL queries or not.
   *
   * @default false
   */
  omitNull?: boolean;

  /**
   * A flag that defines if native library shall be used or not. Currently only has an effect for postgres
   *
   * @default false
   */
  native?: boolean;

  /**
   * Use read / write replication. To enable replication, pass an object, with two properties, read and write.
   * Write should be an object (a single server for handling writes), and read an array of object (several
   * servers to handle reads). Each read/write server can have the following properties: `host`, `port`,
   * `username`, `password`, `database`.  Connection strings can be used instead of objects.
   *
   * @default false
   */
  replication?: ReplicationOptions | false | null | undefined;

  /**
   * Connection pool options
   */
  pool?: PoolOptions;

  /**
   * Set to `false` to make table names and attributes case-insensitive on Postgres and skip double quoting of
   * them.
   *
   * @default true
   */
  quoteIdentifiers?: boolean;

  /**
   * Set the default transaction isolation level. See `Sequelize.Transaction.ISOLATION_LEVELS` for possible
   * options.
   *
   * @default 'REPEATABLE_READ'
   */
  isolationLevel?: ISOLATION_LEVELS;

  /**
   * Set the default transaction type. See Sequelize.Transaction.TYPES for possible options. Sqlite only.
   *
   * @default 'DEFERRED'
   */
  transactionType?: TRANSACTION_TYPES;

  /**
   * Run built in type validators on insert and update, e.g. validate that arguments passed to integer
   * fields are integer-like.
   *
   * @default false
   */
  typeValidation?: boolean;

  /**
   * Sets available operator aliases.
   * See (https://sequelize.org/docs/v7/core-concepts/model-querying-basics/#operators) for more information.
   * WARNING: Setting this to boolean value was deprecated and is no-op.
   *
   * @default all aliases
   */
  operatorsAliases?: OperatorsAliases;

  /**
   * The PostgreSQL `standard_conforming_strings` session parameter. Set to `false` to not set the option.
   * WARNING: Setting this to false may expose vulnerabilities and is not recommended!
   *
   * @default true
   */
  standardConformingStrings?: boolean;

  /**
   * The PostgreSQL `client_min_messages` session parameter.
   * Set to `false` to not override the database's default.
   *
   * Deprecated in v7, please use the sequelize option "dialectOptions.clientMinMessages" instead
   *
   * @deprecated
   * @default 'warning'
   */
  clientMinMessages?: string | boolean;

  /**
   * Sets global permanent hooks.
   */
  hooks?: Partial<SequelizeHooks<Model, any, any>>;

  /**
   * Set to `true` to automatically minify aliases generated by sequelize.
   * Mostly useful to circumvent the POSTGRES alias limit of 64 characters.
   *
   * @default false
   */
  minifyAliases?: boolean;

  /**
   * Set to `true` to show bind parameters in log.
   *
   * @default false
   */
  logQueryParameters?: boolean;

  retry?: RetryOptions;

  /**
   * If defined the connection will use the provided schema instead of the default ("public").
   */
  schema?: string;
}

export interface NormalizedOptions extends PartlyRequired<Options, 'transactionType' | 'isolationLevel' | 'dialectOptions' | 'dialect'> {
  readonly replication: NormalizedReplicationOptions;
}

export interface DialectOptions {
  [key: string]: any;
  account?: string;
  role?: string;
  warehouse?: string;
  schema?: string;
  odbcConnectionString?: string;
  charset?: string;
  timeout?: number;
  options?: Record<string, any>;
}

export interface QueryOptionsTransactionRequired { }

type BindOrReplacements = { [key: string]: unknown } | unknown[];
type FieldMap = { [key: string]: string };

/**
 * Options for {@link Sequelize#queryRaw}.
 */
export interface QueryRawOptions extends Logging, Transactionable, Poolable {
  /**
   * If true, sequelize will not try to format the results of the query, or build an instance of a model from
   * the result
   */
  raw?: boolean;

  /**
   * The type of query you are executing. The query type affects how results are formatted before they are
   * passed back. The type is a string, but `Sequelize.QueryTypes` is provided as convenience shortcuts.
   */
  type?: string;

  /**
   * If true, transforms objects with `.` separated property names into nested objects using
   * [dottie.js](https://github.com/mickhansen/dottie.js). For example { 'user.username': 'john' } becomes
   * { user: { username: 'john' }}. When `nest` is true, the query type is assumed to be `'SELECT'`,
   * unless otherwise specified
   *
   * @default false
   */
  nest?: boolean;

  /**
   * Sets the query type to `SELECT` and return a single row
   */
  plain?: boolean;

  /**
   * Either an object of named parameter bindings in the format `$param` or an array of unnamed
   * values to bind to `$1`, `$2`, etc in your SQL.
   */
  bind?: BindOrReplacements;

  /**
   * A sequelize instance used to build the return instance
   */
  instance?: Model;

  /**
   * Map returned fields to model's fields if `options.model` or `options.instance` is present.
   * Mapping will occur before building the model instance.
   */
  mapToModel?: boolean;

  retry?: RetryOptions;

  /**
   * Map returned fields to arbitrary names for SELECT query type if `options.fieldMaps` is present.
   */
  fieldMap?: FieldMap;
}

export interface QueryRawOptionsWithType<T extends QueryTypes> extends QueryRawOptions {
  /**
   * The type of query you are executing. The query type affects how results are formatted before they are
   * passed back. The type is a string, but `Sequelize.QueryTypes` is provided as convenience shortcuts.
   */
  type: T;
}

export interface QueryRawOptionsWithModel<M extends Model> extends QueryRawOptions {
  /**
   * A sequelize model used to build the returned model instances (used to be called callee)
   */
  model: ModelStatic<M>;
}

/**
 * Options for {@link Sequelize#query}.
 */
export interface QueryOptions extends QueryRawOptions {
  /**
   * Either an object of named parameter replacements in the format `:param` or an array of unnamed
   * replacements to replace `?` in your SQL.
   */
  replacements?: BindOrReplacements;
}

export interface QueryOptionsWithType<T extends QueryTypes> extends QueryOptions {
  /**
   * The type of query you are executing. The query type affects how results are formatted before they are
   * passed back. The type is a string, but `Sequelize.QueryTypes` is provided as convenience shortcuts.
   */
  type: T;
}

export interface QueryOptionsWithModel<M extends Model> extends QueryOptions {
  /**
   * A sequelize model used to build the returned model instances (used to be called callee)
   */
  model: ModelStatic<M>;
}

/**
 * This is the main class, the entry point to sequelize. To use it, you just need to
 * import sequelize:
 *
 * ```js
 * const { Sequelize } = require('@sequelize/core');
 * ```
 *
 * In addition to sequelize, the connection library for the dialect you want to use
 * should also be installed in your project. You don't need to import it however, as
 * sequelize will take care of that.
 */
export class Sequelize extends Hooks {

  // -------------------- Utilities ------------------------------------------------------------------------

  /**
   * Creates a object representing a database function. This can be used in search queries, both in where and
   * order parts, and as default values in column definitions. If you want to refer to columns in your
   * function, you should use `sequelize.col`, so that the columns are properly interpreted as columns and
   * not a strings.
   *
   * Convert a user's username to upper case
   * ```js
   * instance.update({
   *   username: self.sequelize.fn('upper', self.sequelize.col('username'))
   * })
   * ```
   *
   * @param fn The function you want to call
   * @param args All further arguments will be passed as arguments to the function
   */
  static fn: typeof fn;
  fn: typeof fn;

  /**
   * Creates a object representing a column in the DB. This is often useful in conjunction with
   * `sequelize.fn`, since raw string arguments to fn will be escaped.
   *
   * @param col The name of the column
   */
  static col: typeof col;
  col: typeof col;

  /**
   * Creates a object representing a call to the cast function.
   *
   * @param val The value to cast
   * @param type The type to cast it to
   */
  static cast: typeof cast;
  cast: typeof cast;

  /**
   * Creates a object representing a literal, i.e. something that will not be escaped.
   *
   * @param val
   */
  static literal: typeof literal;
  literal: typeof literal;

  /**
   * An AND query
   *
   * @param args Each argument will be joined by AND
   */
  static and: typeof and;
  and: typeof and;

  /**
   * An OR query
   *
   * @param args Each argument will be joined by OR
   */
  static or: typeof or;
  or: typeof or;

  /**
   * Creates an object representing nested where conditions for postgres's json data-type.
   *
   * @param conditionsOrPath A hash containing strings/numbers or other nested hash, a string using dot
   *   notation or a string using postgres json syntax.
   * @param value An optional value to compare against.
   *   Produces a string of the form "&lt;json path&gt; = '&lt;value&gt;'"`.
   */
  static json: typeof json;
  json: typeof json;

  /**
   * A way of specifying attr = condition.
   *
   * The attr can either be an object taken from `Model.rawAttributes` (for example `Model.rawAttributes.id`
   * or
   * `Model.rawAttributes.name`). The attribute should be defined in your model definition. The attribute can
   * also be an object from one of the sequelize utility functions (`sequelize.fn`, `sequelize.col` etc.)
   *
   * For string attributes, use the regular `{ where: { attr: something }}` syntax. If you don't want your
   * string to be escaped, use `sequelize.literal`.
   *
   * @param attr The attribute, which can be either an attribute object from `Model.rawAttributes` or a
   *   sequelize object, for example an instance of `sequelize.fn`. For simple string attributes, use the
   *   POJO syntax
   * @param comparator Comparator
   * @param logic The condition. Can be both a simply type, or a further condition (`.or`, `.and`, `.literal`
   *   etc.)
   */
  static where: typeof where;
  where: typeof where;

  static Op: typeof Op;
  static DataTypes: typeof DataTypes;

  /**
   * A hook that is run before validation
   *
   * @param name
   * @param fn A callback function that is called with instance, options
   */
  static beforeValidate(name: string, fn: (instance: Model, options: ValidationOptions) => void): void;
  static beforeValidate(fn: (instance: Model, options: ValidationOptions) => void): void;

  /**
   * A hook that is run after validation
   *
   * @param name
   * @param fn A callback function that is called with instance, options
   */
  static afterValidate(name: string, fn: (instance: Model, options: ValidationOptions) => void): void;
  static afterValidate(fn: (instance: Model, options: ValidationOptions) => void): void;

  /**
   * A hook that is run before creating a single instance
   *
   * @param name
   * @param fn A callback function that is called with attributes, options
   */
  static beforeCreate(name: string, fn: (attributes: Model, options: CreateOptions<any>) => void): void;
  static beforeCreate(fn: (attributes: Model, options: CreateOptions<any>) => void): void;

  /**
   * A hook that is run after creating a single instance
   *
   * @param name
   * @param fn A callback function that is called with attributes, options
   */
  static afterCreate(name: string, fn: (attributes: Model, options: CreateOptions<any>) => void): void;
  static afterCreate(fn: (attributes: Model, options: CreateOptions<any>) => void): void;

  /**
   * A hook that is run before destroying a single instance
   *
   * @param name
   * @param fn A callback function that is called with instance, options
   */
  static beforeDestroy(name: string, fn: (instance: Model, options: InstanceDestroyOptions) => void): void;
  static beforeDestroy(fn: (instance: Model, options: InstanceDestroyOptions) => void): void;

  /**
   * A hook that is run after destroying a single instance
   *
   * @param name
   * @param fn A callback function that is called with instance, options
   */
  static afterDestroy(name: string, fn: (instance: Model, options: InstanceDestroyOptions) => void): void;
  static afterDestroy(fn: (instance: Model, options: InstanceDestroyOptions) => void): void;

  /**
   * A hook that is run before updating a single instance
   *
   * @param name
   * @param fn A callback function that is called with instance, options
   */
  static beforeUpdate(name: string, fn: (instance: Model, options: UpdateOptions<any>) => void): void;
  static beforeUpdate(fn: (instance: Model, options: UpdateOptions<any>) => void): void;

  /**
   * A hook that is run after updating a single instance
   *
   * @param name
   * @param fn A callback function that is called with instance, options
   */
  static afterUpdate(name: string, fn: (instance: Model, options: UpdateOptions<any>) => void): void;
  static afterUpdate(fn: (instance: Model, options: UpdateOptions<any>) => void): void;

  /**
   * A hook that is run before creating or updating a single instance, It proxies `beforeCreate` and `beforeUpdate`
   *
   * @param name
   * @param fn A callback function that is called with instance, options
   */
  static beforeSave(
    name: string,
    fn: (instance: Model, options: UpdateOptions<any> | CreateOptions<any>) => void
  ): void;
  static beforeSave(fn: (instance: Model, options: UpdateOptions<any> | CreateOptions<any>) => void): void;

  /**
   * A hook that is run after creating or updating a single instance, It proxies `afterCreate` and `afterUpdate`
   *
   * @param name
   * @param fn A callback function that is called with instance, options
   */
  static afterSave(
    name: string,
    fn: (instance: Model, options: UpdateOptions<any> | CreateOptions<any>) => void
  ): void;
  static afterSave(
    fn: (instance: Model, options: UpdateOptions<any> | CreateOptions<any>) => void
  ): void;

  /**
   * A hook that is run before creating instances in bulk
   *
   * @param name
   * @param fn A callback function that is called with instances, options
   */
  static beforeBulkCreate(
    name: string,
    fn: (instances: Model[], options: BulkCreateOptions<any>) => void
  ): void;
  static beforeBulkCreate(fn: (instances: Model[], options: BulkCreateOptions<any>) => void): void;

  /**
   * A hook that is run after creating instances in bulk
   *
   * @param name
   * @param fn A callback function that is called with instances, options
   */
  static afterBulkCreate(
    name: string, fn: (instances: Model[], options: BulkCreateOptions<any>) => void
  ): void;
  static afterBulkCreate(fn: (instances: Model[], options: BulkCreateOptions<any>) => void): void;

  /**
   * A hook that is run before destroying instances in bulk
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  static beforeBulkDestroy(name: string, fn: (options: BulkCreateOptions<any>) => void): void;
  static beforeBulkDestroy(fn: (options: BulkCreateOptions<any>) => void): void;

  /**
   * A hook that is run after destroying instances in bulk
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  static afterBulkDestroy(name: string, fn: (options: DestroyOptions<any>) => void): void;
  static afterBulkDestroy(fn: (options: DestroyOptions<any>) => void): void;

  /**
   * A hook that is run after updating instances in bulk
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  static beforeBulkUpdate(name: string, fn: (options: UpdateOptions<any>) => void): void;
  static beforeBulkUpdate(fn: (options: UpdateOptions<any>) => void): void;

  /**
   * A hook that is run after updating instances in bulk
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  static afterBulkUpdate(name: string, fn: (options: UpdateOptions<any>) => void): void;
  static afterBulkUpdate(fn: (options: UpdateOptions<any>) => void): void;

  /**
   * A hook that is run before a find (select) query
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  static beforeFind(name: string, fn: (options: FindOptions<any>) => void): void;
  static beforeFind(fn: (options: FindOptions<any>) => void): void;

  /**
   * A hook that is run before a connection is established
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  static beforeConnect(name: string, fn: (options: DeepWriteable<Config>) => void): void;
  static beforeConnect(fn: (options: DeepWriteable<Config>) => void): void;
  beforeConnect(name: string, fn: (options: DeepWriteable<Config>) => void): void;
  beforeConnect(fn: (options: DeepWriteable<Config>) => void): void;

  /**
   * A hook that is run after a connection is established
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  static afterConnect(name: string, fn: (connection: unknown, options: Config) => void): void;
  static afterConnect(fn: (connection: unknown, options: Config) => void): void;
  afterConnect(name: string, fn: (connection: unknown, options: Config) => void): void;
  afterConnect(fn: (connection: unknown, options: Config) => void): void;

  /**
   * A hook that is run before a connection is released
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  static beforeDisconnect(name: string, fn: (connection: unknown) => void): void;
  static beforeDisconnect(fn: (connection: unknown) => void): void;
  beforeDisconnect(name: string, fn: (connection: unknown) => void): void;
  beforeDisconnect(fn: (connection: unknown) => void): void;

  /**
   * A hook that is run after a connection is released
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  static afterDisconnect(name: string, fn: (connection: unknown) => void): void;
  static afterDisconnect(fn: (connection: unknown) => void): void;
  afterDisconnect(name: string, fn: (connection: unknown) => void): void;
  afterDisconnect(fn: (connection: unknown) => void): void;

  /**
   * A hook that is run before a find (select) query, after any { include: {all: ...} } options are expanded
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  static beforeFindAfterExpandIncludeAll(name: string, fn: (options: FindOptions<any>) => void): void;
  static beforeFindAfterExpandIncludeAll(fn: (options: FindOptions<any>) => void): void;

  /**
   * A hook that is run before a find (select) query, after all option parsing is complete
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  static beforeFindAfterOptions(name: string, fn: (options: FindOptions<any>) => void): void;
  static beforeFindAfterOptions(fn: (options: FindOptions<any>) => void): void;

  /**
   * A hook that is run after a find (select) query
   *
   * @param name
   * @param fn   A callback function that is called with instance(s), options
   */
  static afterFind(
    name: string,
    fn: (instancesOrInstance: Model[] | Model | null, options: FindOptions<any>) => void
  ): void;
  static afterFind(
    fn: (instancesOrInstance: Model[] | Model | null, options: FindOptions<any>) => void
  ): void;

  /**
   * A hook that is run before a define call
   *
   * @param name
   * @param fn   A callback function that is called with attributes, options
   */
  static beforeDefine<M extends Model>(
    name: string,
    fn: (attributes: ModelAttributes<M, CreationAttributes<M>>, options: ModelOptions<M>) => void
  ): void;
  static beforeDefine<M extends Model>(
    fn: (attributes: ModelAttributes<M, CreationAttributes<M>>, options: ModelOptions<M>) => void
  ): void;

  /**
   * A hook that is run after a define call
   *
   * @param name
   * @param fn   A callback function that is called with factory
   */
  static afterDefine(name: string, fn: (model: ModelStatic) => void): void;
  static afterDefine(fn: (model: ModelStatic) => void): void;

  /**
   * A hook that is run before Sequelize() call
   *
   * @param name
   * @param fn   A callback function that is called with config, options
   */
  static beforeInit(name: string, fn: (config: Config, options: Options) => void): void;
  static beforeInit(fn: (config: Config, options: Options) => void): void;

  /**
   * A hook that is run after Sequelize() call
   *
   * @param name
   * @param fn   A callback function that is called with sequelize
   */
  static afterInit(name: string, fn: (sequelize: Sequelize) => void): void;
  static afterInit(fn: (sequelize: Sequelize) => void): void;

  /**
   * A hook that is run before sequelize.sync call
   *
   * @param fn   A callback function that is called with options passed to sequelize.sync
   */
  static beforeBulkSync(dname: string, fn: (options: SyncOptions) => HookReturn): void;
  static beforeBulkSync(fn: (options: SyncOptions) => HookReturn): void;

  /**
   * A hook that is run after sequelize.sync call
   *
   * @param fn   A callback function that is called with options passed to sequelize.sync
   */
  static afterBulkSync(name: string, fn: (options: SyncOptions) => HookReturn): void;
  static afterBulkSync(fn: (options: SyncOptions) => HookReturn): void;

  /**
   * A hook that is run before Model.sync call
   *
   * @param fn   A callback function that is called with options passed to Model.sync
   */
  static beforeSync(name: string, fn: (options: SyncOptions) => HookReturn): void;
  static beforeSync(fn: (options: SyncOptions) => HookReturn): void;

  /**
   * A hook that is run after Model.sync call
   *
   * @param fn   A callback function that is called with options passed to Model.sync
   */
  static afterSync(name: string, fn: (options: SyncOptions) => HookReturn): void;
  static afterSync(fn: (options: SyncOptions) => HookReturn): void;

  /**
   * Use CLS with Sequelize.
   * CLS namespace provided is stored as `Sequelize._cls`
   * and Promise is patched to use the namespace, using `cls-hooked` module.
   *
   * @param namespace
   */
  static useCLS(namespace: ContinuationLocalStorageNamespace): typeof Sequelize;

  /**
   * A reference to Sequelize constructor from sequelize. Useful for accessing DataTypes, Errors etc.
   */
  Sequelize: typeof Sequelize;

  /**
   * Final config that is used by sequelize.
   */
  readonly config: Config;

  readonly options: NormalizedOptions;

  readonly dialect: AbstractDialect;

  readonly modelManager: ModelManager;

  readonly connectionManager: AbstractConnectionManager;

  /**
   * For internal use only.
   *
   * @type {ContinuationLocalStorageNamespace | undefined}
   */
  static readonly _cls: ContinuationLocalStorageNamespace | undefined;

  /**
   * Dictionary of all models linked with this instance.
   */
  models: {
    [key: string]: ModelStatic<Model>,
  };

  /**
   * Instantiate sequelize with name of database, username and password
   *
   * #### Example usage
   *
   * ```javascript
   * // without password and options
   * const sequelize = new Sequelize('database', 'username')
   *
   * // without options
   * const sequelize = new Sequelize('database', 'username', 'password')
   *
   * // without password / with blank password
   * const sequelize = new Sequelize('database', 'username', null, {})
   *
   * // with password and options
   * const sequelize = new Sequelize('my_database', 'john', 'doe', {})
   *
   * // with uri (see below)
   * const sequelize = new Sequelize('mysql://localhost:3306/database', {})
   * ```
   *
   * @param database The name of the database
   * @param username The username which is used to authenticate against the
   *   database.
   * @param password The password which is used to authenticate against the
   *   database.
   * @param options An object with options.
   */
  constructor(database: string, username: string, password?: string, options?: Options);
  constructor(database: string, username: string, options?: Options);
  constructor(options?: Options);

  /**
   * Instantiate sequelize with an URI
   *
   * @param uri A full database URI
   * @param options See above for possible options
   */
  constructor(uri: string, options?: Options);

  /**
   * A hook that is run before validation
   *
   * @param name
   * @param fn A callback function that is called with instance, options
   */
  beforeValidate(name: string, fn: (instance: Model, options: ValidationOptions) => void): void;
  beforeValidate(fn: (instance: Model, options: ValidationOptions) => void): void;

  /**
   * A hook that is run after validation
   *
   * @param name
   * @param fn A callback function that is called with instance, options
   */
  afterValidate(name: string, fn: (instance: Model, options: ValidationOptions) => void): void;
  afterValidate(fn: (instance: Model, options: ValidationOptions) => void): void;

  /**
   * A hook that is run before creating a single instance
   *
   * @param name
   * @param fn A callback function that is called with attributes, options
   */
  beforeCreate(name: string, fn: (attributes: Model, options: CreateOptions<any>) => void): void;
  beforeCreate(fn: (attributes: Model, options: CreateOptions<any>) => void): void;

  /**
   * A hook that is run after creating a single instance
   *
   * @param name
   * @param fn A callback function that is called with attributes, options
   */
  afterCreate(name: string, fn: (attributes: Model, options: CreateOptions<any>) => void): void;
  afterCreate(fn: (attributes: Model, options: CreateOptions<any>) => void): void;

  /**
   * A hook that is run before destroying a single instance
   *
   * @param name
   * @param fn A callback function that is called with instance, options
   */
  beforeDestroy(name: string, fn: (instance: Model, options: InstanceDestroyOptions) => void): void;
  beforeDestroy(fn: (instance: Model, options: InstanceDestroyOptions) => void): void;

  /**
   * A hook that is run after destroying a single instance
   *
   * @param name
   * @param fn A callback function that is called with instance, options
   */
  afterDestroy(name: string, fn: (instance: Model, options: InstanceDestroyOptions) => void): void;
  afterDestroy(fn: (instance: Model, options: InstanceDestroyOptions) => void): void;

  /**
   * A hook that is run before updating a single instance
   *
   * @param name
   * @param fn A callback function that is called with instance, options
   */
  beforeUpdate(name: string, fn: (instance: Model, options: UpdateOptions<any>) => void): void;
  beforeUpdate(fn: (instance: Model, options: UpdateOptions<any>) => void): void;

  /**
   * A hook that is run after updating a single instance
   *
   * @param name
   * @param fn A callback function that is called with instance, options
   */
  afterUpdate(name: string, fn: (instance: Model, options: UpdateOptions<any>) => void): void;
  afterUpdate(fn: (instance: Model, options: UpdateOptions<any>) => void): void;

  /**
   * A hook that is run before creating instances in bulk
   *
   * @param name
   * @param fn A callback function that is called with instances, options
   */
  beforeBulkCreate(name: string, fn: (instances: Model[], options: BulkCreateOptions<any>) => void): void;
  beforeBulkCreate(fn: (instances: Model[], options: BulkCreateOptions<any>) => void): void;

  /**
   * A hook that is run after creating instances in bulk
   *
   * @param name
   * @param fn A callback function that is called with instances, options
   */
  afterBulkCreate(name: string, fn: (instances: Model[], options: BulkCreateOptions<any>) => void): void;
  afterBulkCreate(fn: (instances: Model[], options: BulkCreateOptions<any>) => void): void;

  /**
   * A hook that is run before destroying instances in bulk
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  beforeBulkDestroy(name: string, fn: (options: BulkCreateOptions<any>) => void): void;
  beforeBulkDestroy(fn: (options: BulkCreateOptions<any>) => void): void;

  /**
   * A hook that is run after destroying instances in bulk
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  afterBulkDestroy(name: string, fn: (options: DestroyOptions<any>) => void): void;
  afterBulkDestroy(fn: (options: DestroyOptions<any>) => void): void;

  /**
   * A hook that is run after updating instances in bulk
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  beforeBulkUpdate(name: string, fn: (options: UpdateOptions<any>) => void): void;
  beforeBulkUpdate(fn: (options: UpdateOptions<any>) => void): void;

  /**
   * A hook that is run after updating instances in bulk
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  afterBulkUpdate(name: string, fn: (options: UpdateOptions<any>) => void): void;
  afterBulkUpdate(fn: (options: UpdateOptions<any>) => void): void;

  /**
   * A hook that is run before a find (select) query
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  beforeFind(name: string, fn: (options: FindOptions<any>) => void): void;
  beforeFind(fn: (options: FindOptions<any>) => void): void;

  /**
   * A hook that is run before a find (select) query, after any { include: {all: ...} } options are expanded
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  beforeFindAfterExpandIncludeAll(name: string, fn: (options: FindOptions<any>) => void): void;
  beforeFindAfterExpandIncludeAll(fn: (options: FindOptions<any>) => void): void;

  /**
   * A hook that is run before a find (select) query, after all option parsing is complete
   *
   * @param name
   * @param fn   A callback function that is called with options
   */
  beforeFindAfterOptions(name: string, fn: (options: FindOptions<any>) => void): void;
  beforeFindAfterOptions(fn: (options: FindOptions<any>) => void): void;

  /**
   * A hook that is run after a find (select) query
   *
   * @param name
   * @param fn   A callback function that is called with instance(s), options
   */
  afterFind(
    name: string,
    fn: (instancesOrInstance: Model[] | Model | null, options: FindOptions<any>) => void
  ): void;
  afterFind(fn: (instancesOrInstance: Model[] | Model | null, options: FindOptions<any>) => void): void;

  /**
   * A hook that is run before a define call
   *
   * @param name
   * @param fn   A callback function that is called with attributes, options
   */
  beforeDefine(name: string, fn: (attributes: ModelAttributes<Model, any>, options: ModelOptions) => void): void;
  beforeDefine(fn: (attributes: ModelAttributes<Model, any>, options: ModelOptions) => void): void;

  /**
   * A hook that is run after a define call
   *
   * @param name
   * @param fn   A callback function that is called with factory
   */
  afterDefine(name: string, fn: (model: ModelStatic) => void): void;
  afterDefine(fn: (model: ModelStatic) => void): void;

  /**
   * A hook that is run before Sequelize() call
   *
   * @param name
   * @param fn   A callback function that is called with config, options
   */
  beforeInit(name: string, fn: (config: Config, options: Options) => void): void;
  beforeInit(fn: (config: Config, options: Options) => void): void;

  /**
   * A hook that is run after Sequelize() call
   *
   * @param name
   * @param fn   A callback function that is called with sequelize
   */
  afterInit(name: string, fn: (sequelize: Sequelize) => void): void;
  afterInit(fn: (sequelize: Sequelize) => void): void;

  /**
   * A hook that is run before sequelize.sync call
   *
   * @param fn   A callback function that is called with options passed to sequelize.sync
   */
  beforeBulkSync(name: string, fn: (options: SyncOptions) => HookReturn): void;
  beforeBulkSync(fn: (options: SyncOptions) => HookReturn): void;

  /**
   * A hook that is run after sequelize.sync call
   *
   * @param fn   A callback function that is called with options passed to sequelize.sync
   */
  afterBulkSync(name: string, fn: (options: SyncOptions) => HookReturn): void;
  afterBulkSync(fn: (options: SyncOptions) => HookReturn): void;

  /**
   * A hook that is run before Model.sync call
   *
   * @param fn   A callback function that is called with options passed to Model.sync
   */
  beforeSync(name: string, fn: (options: SyncOptions) => HookReturn): void;
  beforeSync(fn: (options: SyncOptions) => HookReturn): void;

  /**
   * A hook that is run after Model.sync call
   *
   * @param fn   A callback function that is called with options passed to Model.sync
   */
  afterSync(name: string, fn: (options: SyncOptions) => HookReturn): void;
  afterSync(fn: (options: SyncOptions) => HookReturn): void;

  /**
   * Returns the specified dialect.
   */
  getDialect(): string;

  /**
   * Returns the database name.
   */

  getDatabaseName(): string;

  /**
   * Returns the dialect-dependant QueryInterface instance.
   */
  getQueryInterface(): QueryInterface;

  /**
   * The QueryInterface instance, dialect dependant.
   */
  queryInterface: QueryInterface;

  /**
   * Define a new model, representing a table in the DB.
   *
   * The table columns are defined by the hash that is given as the second argument. Each attribute of the
   * hash
   * represents a column. A short table definition might look like this:
   *
   * ```js
   * class MyModel extends Model {}
   * MyModel.init({
   *   columnA: {
   *     type: DataTypes.BOOLEAN,
   *     validate: {
   *       is: ["[a-z]",'i'],    // will only allow letters
   *       max: 23,          // only allow values <= 23
   *       isIn: {
   *       args: [['en', 'zh']],
   *       msg: "Must be English or Chinese"
   *       }
   *     },
   *     field: 'column_a'
   *     // Other attributes here
   *   },
   *   columnB: DataTypes.STRING,
   *   columnC: 'MY VERY OWN COLUMN TYPE'
   * }, { sequelize })
   *
   * sequelize.models.modelName // The model will now be available in models under the name given to define
   * ```
   *
   * As shown above, column definitions can be either strings, a reference to one of the datatypes that are
   * predefined on the Sequelize constructor, or an object that allows you to specify both the type of the
   * column, and other attributes such as default values, foreign key constraints and custom setters and
   * getters.
   *
   * For a list of possible data types, see
   * https://sequelize.org/docs/v7/other-topics/other-data-types
   *
   * For more about getters and setters, see
   * https://sequelize.org/docs/v7/core-concepts/getters-setters-virtuals/
   *
   * For more about instance and class methods, see
   * https://sequelize.org/docs/v7/core-concepts/model-basics/#taking-advantage-of-models-being-classes
   *
   * For more about validation, see
   * https://sequelize.org/docs/v7/core-concepts/validations-and-constraints/
   *
   * @param modelName  The name of the model. The model will be stored in `sequelize.models` under this name
   * @param attributes An object, where each attribute is a column of the table. Each column can be either a
   *           DataType, a string or a type-description object, with the properties described below:
   * @param options  These options are merged with the default define options provided to the Sequelize
   *           constructor
   */
  define<M extends Model, TAttributes = Attributes<M>>(
    modelName: string,
    attributes?: ModelAttributes<M, TAttributes>,
    options?: ModelOptions<M>
  ): ModelStatic<M>;

  /**
   * Fetch a Model which is already defined
   *
   * @param modelName The name of a model defined with Sequelize.define
   */
  model(modelName: string): ModelStatic<Model>;

  /**
   * Checks whether a model with the given name is defined
   *
   * @param modelName The name of a model defined with Sequelize.define
   */
  isDefined(modelName: string): boolean;

  /**
   * Execute a query on the DB, optionally bypassing all the Sequelize goodness.
   *
   * By default, the function will return two arguments: an array of results, and a metadata object,
   * containing number of affected rows etc. Use `const [results, meta] = await ...` to access the results.
   *
   * If you are running a type of query where you don't need the metadata, for example a `SELECT` query, you
   * can pass in a query type to make sequelize format the results:
   *
   * ```js
   * const [results, metadata] = await sequelize.query('SELECT...'); // Raw query - use array destructuring
   *
   * const results = await sequelize.query('SELECT...', { type: sequelize.QueryTypes.SELECT }); // SELECT query - no destructuring
   * ```
   *
   * @param sql
   * @param options Query options
   */
  /* eslint-disable max-len -- these signatures are more readable if they are all aligned */
  query(sql: string | { query: string, values: unknown[] }, options: QueryOptionsWithType<QueryTypes.UPDATE>): Promise<[undefined, number]>;
  query(sql: string | { query: string, values: unknown[] }, options: QueryOptionsWithType<QueryTypes.BULKUPDATE>): Promise<number>;
  query(sql: string | { query: string, values: unknown[] }, options: QueryOptionsWithType<QueryTypes.INSERT>): Promise<[number, number]>;
  query(sql: string | { query: string, values: unknown[] }, options: QueryOptionsWithType<QueryTypes.UPSERT>): Promise<number>;
  query(sql: string | { query: string, values: unknown[] }, options: QueryOptionsWithType<QueryTypes.DELETE>): Promise<void>;
  query(sql: string | { query: string, values: unknown[] }, options: QueryOptionsWithType<QueryTypes.BULKDELETE>): Promise<number>;
  query(sql: string | { query: string, values: unknown[] }, options: QueryOptionsWithType<QueryTypes.SHOWTABLES>): Promise<string[]>;
  query(sql: string | { query: string, values: unknown[] }, options: QueryOptionsWithType<QueryTypes.DESCRIBE>): Promise<ColumnsDescription>;
  query<M extends Model>(sql: string | { query: string, values: unknown[] }, options: QueryOptionsWithModel<M> & { plain: true }): Promise<M | null>;
  query<M extends Model>(sql: string | { query: string, values: unknown[] }, options: QueryOptionsWithModel<M>): Promise<M[]>;
  query<T extends object>(sql: string | { query: string, values: unknown[] }, options: QueryOptionsWithType<QueryTypes.SELECT> & { plain: true }): Promise<T | null>;
  query<T extends object>(sql: string | { query: string, values: unknown[] }, options: QueryOptionsWithType<QueryTypes.SELECT>): Promise<T[]>;
  query(sql: string | { query: string, values: unknown[] }, options: (QueryOptions | QueryOptionsWithType<QueryTypes.RAW>) & { plain: true }): Promise<{ [key: string]: unknown } | null>;
  query(sql: string | { query: string, values: unknown[] }, options?: QueryOptions | QueryOptionsWithType<QueryTypes.RAW>): Promise<[unknown[], unknown]>;

  /**
   * Works like {@link Sequelize#query}, but does not inline replacements. Only bind parameters are supported.
   *
   * @param sql The SQL to execute
   * @param options The options for the query. See {@link QueryRawOptions} for details.
   */
  queryRaw(sql: string | { query: string, values: unknown[] }, options: QueryRawOptionsWithType<QueryTypes.UPDATE>): Promise<[undefined, number]>;
  queryRaw(sql: string | { query: string, values: unknown[] }, options: QueryRawOptionsWithType<QueryTypes.BULKUPDATE>): Promise<number>;
  queryRaw(sql: string | { query: string, values: unknown[] }, options: QueryRawOptionsWithType<QueryTypes.INSERT>): Promise<[number, number]>;
  queryRaw(sql: string | { query: string, values: unknown[] }, options: QueryRawOptionsWithType<QueryTypes.UPSERT>): Promise<number>;
  queryRaw(sql: string | { query: string, values: unknown[] }, options: QueryRawOptionsWithType<QueryTypes.DELETE>): Promise<void>;
  queryRaw(sql: string | { query: string, values: unknown[] }, options: QueryRawOptionsWithType<QueryTypes.BULKDELETE>): Promise<number>;
  queryRaw(sql: string | { query: string, values: unknown[] }, options: QueryRawOptionsWithType<QueryTypes.SHOWTABLES>): Promise<string[]>;
  queryRaw(sql: string | { query: string, values: unknown[] }, options: QueryRawOptionsWithType<QueryTypes.DESCRIBE>): Promise<ColumnsDescription>;
  queryRaw<M extends Model>(sql: string | { query: string, values: unknown[] }, options: QueryRawOptionsWithModel<M> & { plain: true }): Promise<M | null>;
  queryRaw<M extends Model>(sql: string | { query: string, values: unknown[] }, options: QueryRawOptionsWithModel<M>): Promise<M[]>;
  queryRaw<T extends object>(sql: string | { query: string, values: unknown[] }, options: QueryRawOptionsWithType<QueryTypes.SELECT> & { plain: true }): Promise<T | null>;
  queryRaw<T extends object>(sql: string | { query: string, values: unknown[] }, options: QueryRawOptionsWithType<QueryTypes.SELECT>): Promise<T[]>;
  queryRaw(sql: string | { query: string, values: unknown[] }, options: (QueryRawOptions | QueryRawOptionsWithType<QueryTypes.RAW>) & { plain: true }): Promise<{ [key: string]: unknown } | null>;
  queryRaw(sql: string | { query: string, values: unknown[] }, options?: QueryRawOptions | QueryRawOptionsWithType<QueryTypes.RAW>): Promise<[unknown[], unknown]>;
  /* eslint-enable max-len */

  /**
   * Get the fn for random based on the dialect
   */
  random(): Fn;

  /**
   * Execute a query which would set an environment or user variable. The variables are set per connection,
   * so this function needs a transaction.
   *
   * Only works for MySQL.
   *
   * @param variables object with multiple variables.
   * @param options Query options.
   */
  set(variables: object, options: QueryOptionsTransactionRequired): Promise<unknown>;

  /**
   * Escape value.
   *
   * @param value Value that needs to be escaped
   */
  escape(value: string | number | Date): string;

  /**
   * Create a new database schema.
   *
   * Note,that this is a schema in the
   * [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this command will do nothing.
   *
   * @param schema Name of the schema
   * @param options Options supplied
   */
  createSchema(schema: string, options?: Logging): Promise<unknown>;

  /**
   * Show all defined schemas
   *
   * Note,that this is a schema in the
   * [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this will show all tables.
   *
   * @param options Options supplied
   */
  showAllSchemas(options?: Logging): Promise<object[]>;

  /**
   * Drop a single schema
   *
   * Note,that this is a schema in the
   * [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this drop a table matching the schema name
   *
   * @param schema Name of the schema
   * @param options Options supplied
   */
  dropSchema(schema: string, options?: Logging): Promise<unknown[]>;

  /**
   * Drop all schemas
   *
   * Note,that this is a schema in the
   * [postgres sense of the word](http://www.postgresql.org/docs/9.1/static/ddl-schemas.html),
   * not a database table. In mysql and sqlite, this is the equivalent of drop all tables.
   *
   * @param options Options supplied
   */
  dropAllSchemas(options?: Logging): Promise<unknown[]>;

  /**
   * Sync all defined models to the DB.
   *
   * @param options Sync Options
   */
  sync(options?: SyncOptions): Promise<this>;

  /**
   * Truncate all tables defined through the sequelize models. This is done
   * by calling Model.truncate() on each model.
   *
   * @param [options] The options passed to Model.destroy in addition to truncate
   */
  truncate(options?: DestroyOptions<any>): Promise<unknown[]>;

  /**
   * Drop all tables defined through this sequelize instance. This is done by calling Model.drop on each model
   *
   * @param options The options passed to each call to Model.drop
   */
  drop(options?: DropOptions): Promise<unknown[]>;

  /**
   * Test the connection by trying to authenticate
   *
   * @param options Query Options for authentication
   */
  authenticate(options?: QueryOptions): Promise<void>;
  validate(options?: QueryOptions): Promise<void>;

  /**
   * Start a transaction. When using transactions, you should pass the transaction in the options argument
   * in order for the query to happen under that transaction
   *
   * ```js
   *   try {
   *     const transaction = await sequelize.transaction();
   *     const user = await User.findOne(..., { transaction });
   *     await user.update(..., { transaction });
   *     await transaction.commit();
   *   } catch(err) {
   *     await transaction.rollback();
   *   }
   * })
   * ```
   *
   * A syntax for automatically committing or rolling back based on the promise chain resolution is also
   * supported:
   *
   * ```js
   * try {
   *   await sequelize.transaction(transaction => { // Note that we pass a callback rather than awaiting the call with no arguments
   *     const user = await User.findOne(..., {transaction});
   *     await user.update(..., {transaction});
   *   });
   *   // Committed
   * } catch(err) {
   *   // Rolled back
   *   console.error(err);
   * }
   * ```
   *
   * If you have [CLS](https://github.com/Jeff-Lewis/cls-hooked) enabled, the transaction
   * will automatically be passed to any query that runs witin the callback. To enable CLS, add it do your
   * project, create a namespace and set it on the sequelize constructor:
   *
   * ```js
   * const cls = require('cls-hooked');
   * const namespace = cls.createNamespace('....');
   * const { Sequelize } = require('@sequelize/core');
   * Sequelize.useCLS(namespace);
   * ```
   * Note, that CLS is enabled for all sequelize instances, and all instances will share the same namespace
   *
   * @param options Transaction Options
   * @param autoCallback Callback for the transaction
   */
  transaction<T>(options: TransactionOptions, autoCallback: (t: Transaction) => PromiseLike<T> | T): Promise<T>;
  transaction<T>(autoCallback: (t: Transaction) => PromiseLike<T> | T): Promise<T>;
  transaction(options?: TransactionOptions): Promise<Transaction>;

  /**
   * Close all connections used by this sequelize instance, and free all references so the instance can be
   * garbage collected.
   *
   * Normally this is done on process exit, so you only need to call this method if you are creating multiple
   * instances, and want to garbage collect some of them.
   */
  close(): Promise<void>;

  /**
   * Returns the database version
   */
  databaseVersion(options?: QueryRawOptions): Promise<string>;

  /**
   * Returns the installed version of Sequelize
   */
  static get version(): string;
}

// Utilities

/**
 * Creates a object representing a database function. This can be used in search queries, both in where and
 * order parts, and as default values in column definitions. If you want to refer to columns in your
 * function, you should use `sequelize.col`, so that the columns are properly interpreted as columns and
 * not a strings.
 *
 * Convert a user's username to upper case
 * ```js
 * instance.update({
 *   username: self.sequelize.fn('upper', self.sequelize.col('username'))
 * })
 * ```
 *
 * @param sqlFunction The function you want to call
 * @param args All further arguments will be passed as arguments to the function
 */
export function fn(
  sqlFunction: string,
  ...args: Fn['args']
): Fn;

/**
 * Creates a object representing a column in the DB. This is often useful in conjunction with
 * `sequelize.fn`, since raw string arguments to fn will be escaped.
 *
 * @param columnName The name of the column
 */
export function col(columnName: string): Col;

/**
 * Creates a object representing a call to the cast function.
 *
 * @param val The value to cast
 * @param type The type to cast it to
 */
export function cast(val: unknown, type: string): Cast;

/**
 * Creates a object representing a literal, i.e. something that will not be escaped.
 *
 * @param val
 */
export function literal(val: string): Literal;

/**
 * An AND query
 *
 * @param args Each argument will be joined by AND
 */
export function and<T extends any[]>(...args: T): { [Op.and]: T };

/**
 * An OR query
 *
 * @param args Each argument will be joined by OR
 */
export function or<T extends any[]>(...args: T): { [Op.or]: T };

/**
 * Creates an object representing nested where conditions for postgres's json data-type.
 *
 * @param conditionsOrPath A hash containing strings/numbers or other nested hash, a string using dot
 *   notation or a string using postgres json syntax.
 * @param value An optional value to compare against.
 *   Produces a string of the form "&lt;json path&gt; = '&lt;value&gt;'".
 */
export function json(conditionsOrPath: string | object, value?: string | number | boolean): Json;

export type WhereLeftOperand = Fn | ColumnReference | Literal | Cast | ModelAttributeColumnOptions;

/**
 * A way of specifying "attr = condition".
 * Can be used as a replacement for the POJO syntax (e.g. `where: { name: 'Lily' }`) when you need to compare a column that the POJO syntax cannot represent.
 *
 * @param leftOperand The left side of the comparison.
 *  - A value taken from YourModel.rawAttributes, to reference an attribute.
 *    The attribute must be defined in your model definition.
 *  - A Literal (using {@link Sequelize#literal})
 *  - A SQL Function (using {@link Sequelize#fn})
 *  - A Column name (using {@link Sequelize#col})
 *  Note that simple strings to reference an attribute are not supported. You can use the POJO syntax instead.
 * @param operator The comparison operator to use. If unspecified, defaults to {@link Op.eq}.
 * @param rightOperand The right side of the comparison. Its value depends on the used operator.
 *  See {@link WhereOperators} for information about what value is valid for each operator.
 *
 * @example
 * // Using an attribute as the left operand.
 * // Equal to: WHERE first_name = 'Lily'
 * where(User.rawAttributes.firstName, Op.eq, 'Lily');
 *
 * @example
 * // Using a column name as the left operand.
 * // Equal to: WHERE first_name = 'Lily'
 * where(col('first_name'), Op.eq, 'Lily');
 *
 * @example
 * // Using a SQL function on the left operand.
 * // Equal to: WHERE LOWER(first_name) = 'lily'
 * where(fn('LOWER', col('first_name')), Op.eq, 'lily');
 *
 * @example
 * // Using raw SQL as the left operand.
 * // Equal to: WHERE 'Lily' = 'Lily'
 * where(literal(`'Lily'`), Op.eq, 'Lily');
 */
export function where<OpSymbol extends keyof WhereOperators>(
  leftOperand: WhereLeftOperand | Where,
  operator: OpSymbol,
  rightOperand: WhereOperators[OpSymbol]
): Where;
export function where(leftOperand: any, operator: string, rightOperand: any): Where;
export function where(leftOperand: WhereLeftOperand, rightOperand: WhereAttributeHashValue<any>): Where;

type ContinuationLocalStorageNamespace = {
  get(key: string): unknown,
  set(key: string, value: unknown): void,
};
