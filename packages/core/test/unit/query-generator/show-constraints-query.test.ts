import { createSequelizeInstance, expectsql } from '../../support';

const sequelize = createSequelizeInstance();
const dialect = sequelize.dialect;

describe('QueryGenerator#showConstraintsQuery', () => {
  const queryGenerator = sequelize.queryGenerator;

  it('produces a show constraints query for a table', () => {
    expectsql(() => queryGenerator.showConstraintsQuery('myTable'), {
      db2: `SELECT c.TABSCHEMA AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", c.TABSCHEMA AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", r.REFTABSCHEMA AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteRule", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateRule", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON r.CONSTNAME = k.CONSTNAME AND r.TABNAME = k.TABNAME AND r.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'myTable' AND c.TABSCHEMA = 'DB2INST1' ORDER BY c.CONSTNAME`,
      ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON r.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = CURRENT SCHEMA ORDER BY c.CONSTRAINT_NAME`,
      mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS definition FROM sys.key_constraints UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition] FROM sys.check_constraints c UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition] FROM sys.default_constraints UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS definition FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'dbo' AND t.name = N'myTable' ORDER BY c.constraintName`,
      mysql: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON r.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND r.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND r.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND r.TABLE_NAME = kcu.TABLE_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'sequelize_test' ORDER BY c.CONSTRAINT_NAME`,
      mariadb: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON r.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND r.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND r.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND r.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'sequelize_test' ORDER BY c.CONSTRAINT_NAME`,
      postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", ch.check_clause AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON r.constraint_catalog = kcu.constraint_catalog AND r.constraint_schema = kcu.constraint_schema AND r.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN INFORMATION_SCHEMA.check_constraints ch ON c.constraint_catalog = ch.constraint_catalog AND c.constraint_schema = ch.constraint_schema AND c.constraint_name = ch.constraint_name WHERE c.table_name = 'myTable' AND c.table_schema = 'public' ORDER BY c.constraint_name, kcu.ordinal_position`,
      snowflake: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_CATALOG AS tableCatalog, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, fk.TABLE_SCHEMA AS referencedTableSchema, fk.TABLE_NAME AS referencedTableName, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, c.IS_DEFERRABLE AS isDeferrable, c.INITIALLY_DEFERRED AS initiallyDeferred FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS fk ON r.UNIQUE_CONSTRAINT_CATALOG = fk.CONSTRAINT_CATALOG AND r.UNIQUE_CONSTRAINT_SCHEMA = fk.CONSTRAINT_SCHEMA AND r.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'PUBLIC' ORDER BY c.CONSTRAINT_NAME`,
      sqlite: `SELECT sql FROM sqlite_master WHERE tbl_name = 'myTable'`,
    });
  });

  it('produces a show constraints query for a table with a constraint specified', () => {
    expectsql(() => queryGenerator.showConstraintsQuery('myTable', { constraintName: 'foo_bar' }), {
      db2: `SELECT c.TABSCHEMA AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", c.TABSCHEMA AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", r.REFTABSCHEMA AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteRule", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateRule", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON r.CONSTNAME = k.CONSTNAME AND r.TABNAME = k.TABNAME AND r.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'myTable' AND c.TABSCHEMA = 'DB2INST1' AND c.CONSTNAME = 'foo_bar' ORDER BY c.CONSTNAME`,
      ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON r.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = CURRENT SCHEMA AND c.CONSTRAINT_NAME = 'foo_bar' ORDER BY c.CONSTRAINT_NAME`,
      mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS definition FROM sys.key_constraints UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition] FROM sys.check_constraints c UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition] FROM sys.default_constraints UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS definition FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'dbo' AND t.name = N'myTable' AND c.constraintName = N'foo_bar' ORDER BY c.constraintName`,
      mysql: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON r.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND r.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND r.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND r.TABLE_NAME = kcu.TABLE_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'sequelize_test' AND c.CONSTRAINT_NAME = 'foo_bar' ORDER BY c.CONSTRAINT_NAME`,
      mariadb: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON r.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND r.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND r.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND r.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'sequelize_test' AND c.CONSTRAINT_NAME = 'foo_bar' ORDER BY c.CONSTRAINT_NAME`,
      postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", ch.check_clause AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON r.constraint_catalog = kcu.constraint_catalog AND r.constraint_schema = kcu.constraint_schema AND r.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN INFORMATION_SCHEMA.check_constraints ch ON c.constraint_catalog = ch.constraint_catalog AND c.constraint_schema = ch.constraint_schema AND c.constraint_name = ch.constraint_name WHERE c.table_name = 'myTable' AND c.table_schema = 'public' AND c.constraint_name = 'foo_bar' ORDER BY c.constraint_name, kcu.ordinal_position`,
      snowflake: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_CATALOG AS tableCatalog, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, fk.TABLE_SCHEMA AS referencedTableSchema, fk.TABLE_NAME AS referencedTableName, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, c.IS_DEFERRABLE AS isDeferrable, c.INITIALLY_DEFERRED AS initiallyDeferred FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS fk ON r.UNIQUE_CONSTRAINT_CATALOG = fk.CONSTRAINT_CATALOG AND r.UNIQUE_CONSTRAINT_SCHEMA = fk.CONSTRAINT_SCHEMA AND r.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'PUBLIC' AND c.CONSTRAINT_NAME = 'foo_bar' ORDER BY c.CONSTRAINT_NAME`,
      sqlite: `SELECT sql FROM sqlite_master WHERE tbl_name = 'myTable'`,
    });
  });

  it('produces a show constraints query from a model', () => {
    const MyModel = sequelize.define('MyModel', {});

    expectsql(() => queryGenerator.showConstraintsQuery(MyModel), {
      db2: `SELECT c.TABSCHEMA AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", c.TABSCHEMA AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", r.REFTABSCHEMA AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteRule", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateRule", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON r.CONSTNAME = k.CONSTNAME AND r.TABNAME = k.TABNAME AND r.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'MyModels' AND c.TABSCHEMA = 'DB2INST1' ORDER BY c.CONSTNAME`,
      ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON r.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'MyModels' AND c.TABLE_SCHEMA = CURRENT SCHEMA ORDER BY c.CONSTRAINT_NAME`,
      mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS definition FROM sys.key_constraints UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition] FROM sys.check_constraints c UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition] FROM sys.default_constraints UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS definition FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'dbo' AND t.name = N'MyModels' ORDER BY c.constraintName`,
      mysql: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON r.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND r.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND r.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND r.TABLE_NAME = kcu.TABLE_NAME WHERE c.TABLE_NAME = 'MyModels' AND c.TABLE_SCHEMA = 'sequelize_test' ORDER BY c.CONSTRAINT_NAME`,
      mariadb: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON r.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND r.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND r.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND r.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'MyModels' AND c.TABLE_SCHEMA = 'sequelize_test' ORDER BY c.CONSTRAINT_NAME`,
      postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", ch.check_clause AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON r.constraint_catalog = kcu.constraint_catalog AND r.constraint_schema = kcu.constraint_schema AND r.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN INFORMATION_SCHEMA.check_constraints ch ON c.constraint_catalog = ch.constraint_catalog AND c.constraint_schema = ch.constraint_schema AND c.constraint_name = ch.constraint_name WHERE c.table_name = 'MyModels' AND c.table_schema = 'public' ORDER BY c.constraint_name, kcu.ordinal_position`,
      snowflake: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_CATALOG AS tableCatalog, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, fk.TABLE_SCHEMA AS referencedTableSchema, fk.TABLE_NAME AS referencedTableName, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, c.IS_DEFERRABLE AS isDeferrable, c.INITIALLY_DEFERRED AS initiallyDeferred FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS fk ON r.UNIQUE_CONSTRAINT_CATALOG = fk.CONSTRAINT_CATALOG AND r.UNIQUE_CONSTRAINT_SCHEMA = fk.CONSTRAINT_SCHEMA AND r.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'MyModels' AND c.TABLE_SCHEMA = 'PUBLIC' ORDER BY c.CONSTRAINT_NAME`,
      sqlite: `SELECT sql FROM sqlite_master WHERE tbl_name = 'MyModels'`,
    });
  });

  it('produces a show constraints query for a table and schema', () => {
    expectsql(() => queryGenerator.showConstraintsQuery({ tableName: 'myTable', schema: 'mySchema' }), {
      db2: `SELECT c.TABSCHEMA AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", c.TABSCHEMA AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", r.REFTABSCHEMA AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteRule", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateRule", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON r.CONSTNAME = k.CONSTNAME AND r.TABNAME = k.TABNAME AND r.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'myTable' AND c.TABSCHEMA = 'mySchema' ORDER BY c.CONSTNAME`,
      ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON r.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'mySchema' ORDER BY c.CONSTRAINT_NAME`,
      mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS definition FROM sys.key_constraints UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition] FROM sys.check_constraints c UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition] FROM sys.default_constraints UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS definition FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'mySchema' AND t.name = N'myTable' ORDER BY c.constraintName`,
      mysql: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON r.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND r.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND r.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND r.TABLE_NAME = kcu.TABLE_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'mySchema' ORDER BY c.CONSTRAINT_NAME`,
      mariadb: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON r.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND r.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND r.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND r.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'mySchema' ORDER BY c.CONSTRAINT_NAME`,
      postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", ch.check_clause AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON r.constraint_catalog = kcu.constraint_catalog AND r.constraint_schema = kcu.constraint_schema AND r.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN INFORMATION_SCHEMA.check_constraints ch ON c.constraint_catalog = ch.constraint_catalog AND c.constraint_schema = ch.constraint_schema AND c.constraint_name = ch.constraint_name WHERE c.table_name = 'myTable' AND c.table_schema = 'mySchema' ORDER BY c.constraint_name, kcu.ordinal_position`,
      snowflake: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_CATALOG AS tableCatalog, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, fk.TABLE_SCHEMA AS referencedTableSchema, fk.TABLE_NAME AS referencedTableName, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, c.IS_DEFERRABLE AS isDeferrable, c.INITIALLY_DEFERRED AS initiallyDeferred FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS fk ON r.UNIQUE_CONSTRAINT_CATALOG = fk.CONSTRAINT_CATALOG AND r.UNIQUE_CONSTRAINT_SCHEMA = fk.CONSTRAINT_SCHEMA AND r.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'mySchema' ORDER BY c.CONSTRAINT_NAME`,
      sqlite: `SELECT sql FROM sqlite_master WHERE tbl_name = 'mySchema.myTable'`,
    });
  });

  it('produces a show constraints query for a table and default schema', () => {
    expectsql(() => queryGenerator.showConstraintsQuery({ tableName: 'myTable', schema: dialect.getDefaultSchema() }), {
      db2: `SELECT c.TABSCHEMA AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", c.TABSCHEMA AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", r.REFTABSCHEMA AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteRule", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateRule", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON r.CONSTNAME = k.CONSTNAME AND r.TABNAME = k.TABNAME AND r.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'myTable' AND c.TABSCHEMA = 'DB2INST1' ORDER BY c.CONSTNAME`,
      ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON r.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = CURRENT SCHEMA ORDER BY c.CONSTRAINT_NAME`,
      mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS definition FROM sys.key_constraints UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition] FROM sys.check_constraints c UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition] FROM sys.default_constraints UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS definition FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'dbo' AND t.name = N'myTable' ORDER BY c.constraintName`,
      mysql: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON r.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND r.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND r.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND r.TABLE_NAME = kcu.TABLE_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'sequelize_test' ORDER BY c.CONSTRAINT_NAME`,
      mariadb: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON r.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND r.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND r.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND r.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'sequelize_test' ORDER BY c.CONSTRAINT_NAME`,
      postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", ch.check_clause AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON r.constraint_catalog = kcu.constraint_catalog AND r.constraint_schema = kcu.constraint_schema AND r.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN INFORMATION_SCHEMA.check_constraints ch ON c.constraint_catalog = ch.constraint_catalog AND c.constraint_schema = ch.constraint_schema AND c.constraint_name = ch.constraint_name WHERE c.table_name = 'myTable' AND c.table_schema = 'public' ORDER BY c.constraint_name, kcu.ordinal_position`,
      snowflake: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_CATALOG AS tableCatalog, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, fk.TABLE_SCHEMA AS referencedTableSchema, fk.TABLE_NAME AS referencedTableName, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, c.IS_DEFERRABLE AS isDeferrable, c.INITIALLY_DEFERRED AS initiallyDeferred FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS fk ON r.UNIQUE_CONSTRAINT_CATALOG = fk.CONSTRAINT_CATALOG AND r.UNIQUE_CONSTRAINT_SCHEMA = fk.CONSTRAINT_SCHEMA AND r.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'PUBLIC' ORDER BY c.CONSTRAINT_NAME`,
      sqlite: `SELECT sql FROM sqlite_master WHERE tbl_name = 'myTable'`,
    });
  });

  it('produces a show constraints query for a table and globally set schema', () => {
    const sequelizeSchema = createSequelizeInstance({ schema: 'mySchema' });
    const queryGeneratorSchema = sequelizeSchema.queryGenerator;

    expectsql(() => queryGeneratorSchema.showConstraintsQuery('myTable'), {
      db2: `SELECT c.TABSCHEMA AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", c.TABSCHEMA AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", r.REFTABSCHEMA AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteRule", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateRule", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON r.CONSTNAME = k.CONSTNAME AND r.TABNAME = k.TABNAME AND r.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'myTable' AND c.TABSCHEMA = 'mySchema' ORDER BY c.CONSTNAME`,
      ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON r.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'mySchema' ORDER BY c.CONSTRAINT_NAME`,
      mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS definition FROM sys.key_constraints UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition] FROM sys.check_constraints c UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition] FROM sys.default_constraints UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS definition FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'mySchema' AND t.name = N'myTable' ORDER BY c.constraintName`,
      mysql: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON r.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND r.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND r.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND r.TABLE_NAME = kcu.TABLE_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'mySchema' ORDER BY c.CONSTRAINT_NAME`,
      mariadb: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON r.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND r.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND r.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND r.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'mySchema' ORDER BY c.CONSTRAINT_NAME`,
      postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", ch.check_clause AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON r.constraint_catalog = kcu.constraint_catalog AND r.constraint_schema = kcu.constraint_schema AND r.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN INFORMATION_SCHEMA.check_constraints ch ON c.constraint_catalog = ch.constraint_catalog AND c.constraint_schema = ch.constraint_schema AND c.constraint_name = ch.constraint_name WHERE c.table_name = 'myTable' AND c.table_schema = 'mySchema' ORDER BY c.constraint_name, kcu.ordinal_position`,
      snowflake: `SELECT c.CONSTRAINT_CATALOG AS constraintCatalog, c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_CATALOG AS tableCatalog, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, fk.TABLE_SCHEMA AS referencedTableSchema, fk.TABLE_NAME AS referencedTableName, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, c.IS_DEFERRABLE AS isDeferrable, c.INITIALLY_DEFERRED AS initiallyDeferred FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS fk ON r.UNIQUE_CONSTRAINT_CATALOG = fk.CONSTRAINT_CATALOG AND r.UNIQUE_CONSTRAINT_SCHEMA = fk.CONSTRAINT_SCHEMA AND r.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'mySchema' ORDER BY c.CONSTRAINT_NAME`,
      sqlite: `SELECT sql FROM sqlite_master WHERE tbl_name = 'mySchema.myTable'`,
    });
  });

  it('produces a show constraints query for a table with schema and custom delimiter argument', () => {
    // This test is only relevant for dialects that do not support schemas
    if (dialect.supports.schemas) {
      return;
    }

    expectsql(() => queryGenerator.showConstraintsQuery({ tableName: 'myTable', schema: 'mySchema', delimiter: 'custom' }), {
      sqlite: `SELECT sql FROM sqlite_master WHERE tbl_name = 'mySchemacustommyTable'`,
    });
  });
});
