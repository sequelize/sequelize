import { buildInvalidOptionReceivedError } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/check.js';
import { createSequelizeInstance, expectsql } from '../../support';

const sequelize = createSequelizeInstance();
const dialect = sequelize.dialect;

describe('QueryGenerator#showConstraintsQuery', () => {
  const queryGenerator = sequelize.queryGenerator;

  it('produces a show constraints query for a table', () => {
    expectsql(() => queryGenerator.showConstraintsQuery('myTable'), {
      db2: `SELECT TRIM(c.TABSCHEMA) AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", TRIM(c.TABSCHEMA) AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", TRIM(r.REFTABSCHEMA) AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteAction", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateAction", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON c.CONSTNAME = k.CONSTNAME AND c.TABNAME = k.TABNAME AND c.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'myTable' AND c.TABSCHEMA = 'DB2INST1' ORDER BY c.CONSTNAME, k.COLSEQ, fk.COLSEQ`,
      ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON c.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = CURRENT SCHEMA ORDER BY c.CONSTRAINT_NAME, k.ORDINAL_POSITION, fk.ORDINAL_POSITION`,
      mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableSchema, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT kc.[name] AS constraintName, kc.[type_desc] AS constraintType, kc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS [definition], null AS column_id FROM sys.key_constraints kc LEFT JOIN sys.indexes i ON kc.name = i.name LEFT JOIN sys.index_columns ic ON ic.index_id = i.index_id AND ic.object_id = kc.parent_object_id LEFT JOIN sys.columns c ON c.column_id = ic.column_id AND c.object_id = kc.parent_object_id UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.check_constraints c UNION ALL SELECT dc.[name] AS constraintName, dc.[type_desc] AS constraintType, dc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.default_constraints dc INNER JOIN sys.columns c ON dc.parent_column_id = c.column_id AND dc.parent_object_id = c.object_id UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_SCHEMA_NAME(k.[referenced_object_id]) as referencedTableSchema, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS [definition], rcol.column_id FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'dbo' AND t.name = N'myTable' ORDER BY c.constraintName, c.column_id`,
      postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", pg_get_expr(pgc.conbin, pgc.conrelid) AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON c.constraint_catalog = kcu.constraint_catalog AND c.constraint_schema = kcu.constraint_schema AND c.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN pg_constraint pgc ON c.constraint_name = pgc.conname AND c.table_schema = (SELECT nspname FROM pg_namespace WHERE oid = pgc.connamespace) AND c.table_name = pgc.conrelid::regclass::text WHERE c.table_name = 'myTable' AND c.table_schema = 'public' ORDER BY c.constraint_name, kcu.ordinal_position, ccu.column_name`,
      snowflake: `SELECT c.CONSTRAINT_CATALOG AS "constraintCatalog", c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_CATALOG AS "tableCatalog", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", r.DELETE_RULE AS "deleteAction", r.UPDATE_RULE AS "updateAction", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS fk ON r.UNIQUE_CONSTRAINT_CATALOG = fk.CONSTRAINT_CATALOG AND r.UNIQUE_CONSTRAINT_SCHEMA = fk.CONSTRAINT_SCHEMA AND r.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'PUBLIC' ORDER BY c.CONSTRAINT_NAME`,
      sqlite3: `SELECT sql FROM sqlite_master WHERE tbl_name = 'myTable'`,
      'mariadb mysql': `SELECT c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_SCHEMA AS referencedTableSchema, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON c.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND c.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'sequelize_test' ORDER BY c.CONSTRAINT_NAME, kcu.ORDINAL_POSITION`,
    });
  });

  it('produces a show constraints query for a table with a constraint name specified', () => {
    expectsql(() => queryGenerator.showConstraintsQuery('myTable', { constraintName: 'foo_bar' }), {
      db2: `SELECT TRIM(c.TABSCHEMA) AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", TRIM(c.TABSCHEMA) AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", TRIM(r.REFTABSCHEMA) AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteAction", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateAction", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON c.CONSTNAME = k.CONSTNAME AND c.TABNAME = k.TABNAME AND c.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'myTable' AND c.TABSCHEMA = 'DB2INST1' AND c.CONSTNAME = 'foo_bar' ORDER BY c.CONSTNAME, k.COLSEQ, fk.COLSEQ`,
      ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON c.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = CURRENT SCHEMA AND c.CONSTRAINT_NAME = 'foo_bar' ORDER BY c.CONSTRAINT_NAME, k.ORDINAL_POSITION, fk.ORDINAL_POSITION`,
      mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableSchema, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT kc.[name] AS constraintName, kc.[type_desc] AS constraintType, kc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS [definition], null AS column_id FROM sys.key_constraints kc LEFT JOIN sys.indexes i ON kc.name = i.name LEFT JOIN sys.index_columns ic ON ic.index_id = i.index_id AND ic.object_id = kc.parent_object_id LEFT JOIN sys.columns c ON c.column_id = ic.column_id AND c.object_id = kc.parent_object_id UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.check_constraints c UNION ALL SELECT dc.[name] AS constraintName, dc.[type_desc] AS constraintType, dc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.default_constraints dc INNER JOIN sys.columns c ON dc.parent_column_id = c.column_id AND dc.parent_object_id = c.object_id UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_SCHEMA_NAME(k.[referenced_object_id]) as referencedTableSchema, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS [definition], rcol.column_id FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'dbo' AND t.name = N'myTable' AND c.constraintName = N'foo_bar' ORDER BY c.constraintName, c.column_id`,
      postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", pg_get_expr(pgc.conbin, pgc.conrelid) AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON c.constraint_catalog = kcu.constraint_catalog AND c.constraint_schema = kcu.constraint_schema AND c.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN pg_constraint pgc ON c.constraint_name = pgc.conname AND c.table_schema = (SELECT nspname FROM pg_namespace WHERE oid = pgc.connamespace) AND c.table_name = pgc.conrelid::regclass::text WHERE c.table_name = 'myTable' AND c.table_schema = 'public' AND c.constraint_name = 'foo_bar' ORDER BY c.constraint_name, kcu.ordinal_position, ccu.column_name`,
      snowflake: `SELECT c.CONSTRAINT_CATALOG AS "constraintCatalog", c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_CATALOG AS "tableCatalog", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", r.DELETE_RULE AS "deleteAction", r.UPDATE_RULE AS "updateAction", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS fk ON r.UNIQUE_CONSTRAINT_CATALOG = fk.CONSTRAINT_CATALOG AND r.UNIQUE_CONSTRAINT_SCHEMA = fk.CONSTRAINT_SCHEMA AND r.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'PUBLIC' AND c.CONSTRAINT_NAME = 'foo_bar' ORDER BY c.CONSTRAINT_NAME`,
      sqlite3: `SELECT sql FROM sqlite_master WHERE tbl_name = 'myTable'`,
      'mariadb mysql': `SELECT c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_SCHEMA AS referencedTableSchema, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON c.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND c.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'sequelize_test' AND c.CONSTRAINT_NAME = 'foo_bar' ORDER BY c.CONSTRAINT_NAME, kcu.ORDINAL_POSITION`,
    });
  });

  it('produces a show constraints query for a table with a constraint type specified', () => {
    expectsql(
      () => queryGenerator.showConstraintsQuery('myTable', { constraintType: 'FOREIGN KEY' }),
      {
        db2: `SELECT TRIM(c.TABSCHEMA) AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", TRIM(c.TABSCHEMA) AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", TRIM(r.REFTABSCHEMA) AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteAction", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateAction", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON c.CONSTNAME = k.CONSTNAME AND c.TABNAME = k.TABNAME AND c.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'myTable' AND c.TABSCHEMA = 'DB2INST1' AND c.TYPE = 'F' ORDER BY c.CONSTNAME, k.COLSEQ, fk.COLSEQ`,
        ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON c.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = CURRENT SCHEMA AND c.CONSTRAINT_TYPE = 'FOREIGN KEY' ORDER BY c.CONSTRAINT_NAME, k.ORDINAL_POSITION, fk.ORDINAL_POSITION`,
        mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableSchema, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT kc.[name] AS constraintName, kc.[type_desc] AS constraintType, kc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS [definition], null AS column_id FROM sys.key_constraints kc LEFT JOIN sys.indexes i ON kc.name = i.name LEFT JOIN sys.index_columns ic ON ic.index_id = i.index_id AND ic.object_id = kc.parent_object_id LEFT JOIN sys.columns c ON c.column_id = ic.column_id AND c.object_id = kc.parent_object_id UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.check_constraints c UNION ALL SELECT dc.[name] AS constraintName, dc.[type_desc] AS constraintType, dc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.default_constraints dc INNER JOIN sys.columns c ON dc.parent_column_id = c.column_id AND dc.parent_object_id = c.object_id UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_SCHEMA_NAME(k.[referenced_object_id]) as referencedTableSchema, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS [definition], rcol.column_id FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'dbo' AND t.name = N'myTable' AND c.constraintType = N'FOREIGN_KEY_CONSTRAINT' ORDER BY c.constraintName, c.column_id`,
        postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", pg_get_expr(pgc.conbin, pgc.conrelid) AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON c.constraint_catalog = kcu.constraint_catalog AND c.constraint_schema = kcu.constraint_schema AND c.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN pg_constraint pgc ON c.constraint_name = pgc.conname AND c.table_schema = (SELECT nspname FROM pg_namespace WHERE oid = pgc.connamespace) AND c.table_name = pgc.conrelid::regclass::text WHERE c.table_name = 'myTable' AND c.table_schema = 'public' AND c.constraint_type = 'FOREIGN KEY' ORDER BY c.constraint_name, kcu.ordinal_position, ccu.column_name`,
        snowflake: `SELECT c.CONSTRAINT_CATALOG AS "constraintCatalog", c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_CATALOG AS "tableCatalog", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", r.DELETE_RULE AS "deleteAction", r.UPDATE_RULE AS "updateAction", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS fk ON r.UNIQUE_CONSTRAINT_CATALOG = fk.CONSTRAINT_CATALOG AND r.UNIQUE_CONSTRAINT_SCHEMA = fk.CONSTRAINT_SCHEMA AND r.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'PUBLIC' AND c.CONSTRAINT_TYPE = 'FOREIGN KEY' ORDER BY c.CONSTRAINT_NAME`,
        sqlite3: `SELECT sql FROM sqlite_master WHERE tbl_name = 'myTable'`,
        'mariadb mysql': `SELECT c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_SCHEMA AS referencedTableSchema, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON c.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND c.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'sequelize_test' AND c.CONSTRAINT_TYPE = 'FOREIGN KEY' ORDER BY c.CONSTRAINT_NAME, kcu.ORDINAL_POSITION`,
      },
    );
  });

  it('produces a show constraints query for a table with a column name specified', () => {
    expectsql(() => queryGenerator.showConstraintsQuery('myTable', { columnName: 'some_column' }), {
      db2: `SELECT TRIM(c.TABSCHEMA) AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", TRIM(c.TABSCHEMA) AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", TRIM(r.REFTABSCHEMA) AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteAction", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateAction", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON c.CONSTNAME = k.CONSTNAME AND c.TABNAME = k.TABNAME AND c.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'myTable' AND c.TABSCHEMA = 'DB2INST1' AND k.COLNAME = 'some_column' ORDER BY c.CONSTNAME, k.COLSEQ, fk.COLSEQ`,
      ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON c.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = CURRENT SCHEMA AND k.COLUMN_NAME = 'some_column' ORDER BY c.CONSTRAINT_NAME, k.ORDINAL_POSITION, fk.ORDINAL_POSITION`,
      mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableSchema, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT kc.[name] AS constraintName, kc.[type_desc] AS constraintType, kc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS [definition], null AS column_id FROM sys.key_constraints kc LEFT JOIN sys.indexes i ON kc.name = i.name LEFT JOIN sys.index_columns ic ON ic.index_id = i.index_id AND ic.object_id = kc.parent_object_id LEFT JOIN sys.columns c ON c.column_id = ic.column_id AND c.object_id = kc.parent_object_id UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.check_constraints c UNION ALL SELECT dc.[name] AS constraintName, dc.[type_desc] AS constraintType, dc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.default_constraints dc INNER JOIN sys.columns c ON dc.parent_column_id = c.column_id AND dc.parent_object_id = c.object_id UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_SCHEMA_NAME(k.[referenced_object_id]) as referencedTableSchema, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS [definition], rcol.column_id FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'dbo' AND t.name = N'myTable' AND c.columnNames = N'some_column' ORDER BY c.constraintName, c.column_id`,
      postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", pg_get_expr(pgc.conbin, pgc.conrelid) AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON c.constraint_catalog = kcu.constraint_catalog AND c.constraint_schema = kcu.constraint_schema AND c.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN pg_constraint pgc ON c.constraint_name = pgc.conname AND c.table_schema = (SELECT nspname FROM pg_namespace WHERE oid = pgc.connamespace) AND c.table_name = pgc.conrelid::regclass::text WHERE c.table_name = 'myTable' AND c.table_schema = 'public' AND kcu.column_name = 'some_column' ORDER BY c.constraint_name, kcu.ordinal_position, ccu.column_name`,
      snowflake: buildInvalidOptionReceivedError('showConstraintsQuery', dialect.name, [
        'columnName',
      ]),
      sqlite3: `SELECT sql FROM sqlite_master WHERE tbl_name = 'myTable'`,
      'mariadb mysql': `SELECT c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_SCHEMA AS referencedTableSchema, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON c.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND c.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'sequelize_test' AND kcu.COLUMN_NAME = 'some_column' ORDER BY c.CONSTRAINT_NAME, kcu.ORDINAL_POSITION`,
    });
  });

  it('produces a show constraints query from a model', () => {
    const MyModel = sequelize.define('MyModel', {});

    expectsql(() => queryGenerator.showConstraintsQuery(MyModel), {
      db2: `SELECT TRIM(c.TABSCHEMA) AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", TRIM(c.TABSCHEMA) AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", TRIM(r.REFTABSCHEMA) AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteAction", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateAction", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON c.CONSTNAME = k.CONSTNAME AND c.TABNAME = k.TABNAME AND c.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'MyModels' AND c.TABSCHEMA = 'DB2INST1' ORDER BY c.CONSTNAME, k.COLSEQ, fk.COLSEQ`,
      ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON c.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'MyModels' AND c.TABLE_SCHEMA = CURRENT SCHEMA ORDER BY c.CONSTRAINT_NAME, k.ORDINAL_POSITION, fk.ORDINAL_POSITION`,
      mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableSchema, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT kc.[name] AS constraintName, kc.[type_desc] AS constraintType, kc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS [definition], null AS column_id FROM sys.key_constraints kc LEFT JOIN sys.indexes i ON kc.name = i.name LEFT JOIN sys.index_columns ic ON ic.index_id = i.index_id AND ic.object_id = kc.parent_object_id LEFT JOIN sys.columns c ON c.column_id = ic.column_id AND c.object_id = kc.parent_object_id UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.check_constraints c UNION ALL SELECT dc.[name] AS constraintName, dc.[type_desc] AS constraintType, dc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.default_constraints dc INNER JOIN sys.columns c ON dc.parent_column_id = c.column_id AND dc.parent_object_id = c.object_id UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_SCHEMA_NAME(k.[referenced_object_id]) as referencedTableSchema, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS [definition], rcol.column_id FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'dbo' AND t.name = N'MyModels' ORDER BY c.constraintName, c.column_id`,
      postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", pg_get_expr(pgc.conbin, pgc.conrelid) AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON c.constraint_catalog = kcu.constraint_catalog AND c.constraint_schema = kcu.constraint_schema AND c.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN pg_constraint pgc ON c.constraint_name = pgc.conname AND c.table_schema = (SELECT nspname FROM pg_namespace WHERE oid = pgc.connamespace) AND c.table_name = pgc.conrelid::regclass::text WHERE c.table_name = 'MyModels' AND c.table_schema = 'public' ORDER BY c.constraint_name, kcu.ordinal_position, ccu.column_name`,
      snowflake: `SELECT c.CONSTRAINT_CATALOG AS "constraintCatalog", c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_CATALOG AS "tableCatalog", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", r.DELETE_RULE AS "deleteAction", r.UPDATE_RULE AS "updateAction", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS fk ON r.UNIQUE_CONSTRAINT_CATALOG = fk.CONSTRAINT_CATALOG AND r.UNIQUE_CONSTRAINT_SCHEMA = fk.CONSTRAINT_SCHEMA AND r.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'MyModels' AND c.TABLE_SCHEMA = 'PUBLIC' ORDER BY c.CONSTRAINT_NAME`,
      sqlite3: `SELECT sql FROM sqlite_master WHERE tbl_name = 'MyModels'`,
      'mariadb mysql': `SELECT c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_SCHEMA AS referencedTableSchema, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON c.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND c.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'MyModels' AND c.TABLE_SCHEMA = 'sequelize_test' ORDER BY c.CONSTRAINT_NAME, kcu.ORDINAL_POSITION`,
    });
  });

  it('produces a show constraints query from a model definition', () => {
    const MyModel = sequelize.define('MyModel', {});
    const myDefinition = MyModel.modelDefinition;

    expectsql(() => queryGenerator.showConstraintsQuery(myDefinition), {
      db2: `SELECT TRIM(c.TABSCHEMA) AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", TRIM(c.TABSCHEMA) AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", TRIM(r.REFTABSCHEMA) AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteAction", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateAction", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON c.CONSTNAME = k.CONSTNAME AND c.TABNAME = k.TABNAME AND c.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'MyModels' AND c.TABSCHEMA = 'DB2INST1' ORDER BY c.CONSTNAME, k.COLSEQ, fk.COLSEQ`,
      ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON c.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'MyModels' AND c.TABLE_SCHEMA = CURRENT SCHEMA ORDER BY c.CONSTRAINT_NAME, k.ORDINAL_POSITION, fk.ORDINAL_POSITION`,
      mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableSchema, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT kc.[name] AS constraintName, kc.[type_desc] AS constraintType, kc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS [definition], null AS column_id FROM sys.key_constraints kc LEFT JOIN sys.indexes i ON kc.name = i.name LEFT JOIN sys.index_columns ic ON ic.index_id = i.index_id AND ic.object_id = kc.parent_object_id LEFT JOIN sys.columns c ON c.column_id = ic.column_id AND c.object_id = kc.parent_object_id UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.check_constraints c UNION ALL SELECT dc.[name] AS constraintName, dc.[type_desc] AS constraintType, dc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.default_constraints dc INNER JOIN sys.columns c ON dc.parent_column_id = c.column_id AND dc.parent_object_id = c.object_id UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_SCHEMA_NAME(k.[referenced_object_id]) as referencedTableSchema, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS [definition], rcol.column_id FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'dbo' AND t.name = N'MyModels' ORDER BY c.constraintName, c.column_id`,
      postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", pg_get_expr(pgc.conbin, pgc.conrelid) AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON c.constraint_catalog = kcu.constraint_catalog AND c.constraint_schema = kcu.constraint_schema AND c.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN pg_constraint pgc ON c.constraint_name = pgc.conname AND c.table_schema = (SELECT nspname FROM pg_namespace WHERE oid = pgc.connamespace) AND c.table_name = pgc.conrelid::regclass::text WHERE c.table_name = 'MyModels' AND c.table_schema = 'public' ORDER BY c.constraint_name, kcu.ordinal_position, ccu.column_name`,
      snowflake: `SELECT c.CONSTRAINT_CATALOG AS "constraintCatalog", c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_CATALOG AS "tableCatalog", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", r.DELETE_RULE AS "deleteAction", r.UPDATE_RULE AS "updateAction", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS fk ON r.UNIQUE_CONSTRAINT_CATALOG = fk.CONSTRAINT_CATALOG AND r.UNIQUE_CONSTRAINT_SCHEMA = fk.CONSTRAINT_SCHEMA AND r.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'MyModels' AND c.TABLE_SCHEMA = 'PUBLIC' ORDER BY c.CONSTRAINT_NAME`,
      sqlite3: `SELECT sql FROM sqlite_master WHERE tbl_name = 'MyModels'`,
      'mariadb mysql': `SELECT c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_SCHEMA AS referencedTableSchema, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON c.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND c.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'MyModels' AND c.TABLE_SCHEMA = 'sequelize_test' ORDER BY c.CONSTRAINT_NAME, kcu.ORDINAL_POSITION`,
    });
  });

  it('produces a show constraints query for a table and schema', () => {
    expectsql(
      () => queryGenerator.showConstraintsQuery({ tableName: 'myTable', schema: 'mySchema' }),
      {
        db2: `SELECT TRIM(c.TABSCHEMA) AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", TRIM(c.TABSCHEMA) AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", TRIM(r.REFTABSCHEMA) AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteAction", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateAction", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON c.CONSTNAME = k.CONSTNAME AND c.TABNAME = k.TABNAME AND c.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'myTable' AND c.TABSCHEMA = 'mySchema' ORDER BY c.CONSTNAME, k.COLSEQ, fk.COLSEQ`,
        ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON c.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'mySchema' ORDER BY c.CONSTRAINT_NAME, k.ORDINAL_POSITION, fk.ORDINAL_POSITION`,
        mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableSchema, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT kc.[name] AS constraintName, kc.[type_desc] AS constraintType, kc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS [definition], null AS column_id FROM sys.key_constraints kc LEFT JOIN sys.indexes i ON kc.name = i.name LEFT JOIN sys.index_columns ic ON ic.index_id = i.index_id AND ic.object_id = kc.parent_object_id LEFT JOIN sys.columns c ON c.column_id = ic.column_id AND c.object_id = kc.parent_object_id UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.check_constraints c UNION ALL SELECT dc.[name] AS constraintName, dc.[type_desc] AS constraintType, dc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.default_constraints dc INNER JOIN sys.columns c ON dc.parent_column_id = c.column_id AND dc.parent_object_id = c.object_id UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_SCHEMA_NAME(k.[referenced_object_id]) as referencedTableSchema, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS [definition], rcol.column_id FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'mySchema' AND t.name = N'myTable' ORDER BY c.constraintName, c.column_id`,
        postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", pg_get_expr(pgc.conbin, pgc.conrelid) AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON c.constraint_catalog = kcu.constraint_catalog AND c.constraint_schema = kcu.constraint_schema AND c.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN pg_constraint pgc ON c.constraint_name = pgc.conname AND c.table_schema = (SELECT nspname FROM pg_namespace WHERE oid = pgc.connamespace) AND c.table_name = pgc.conrelid::regclass::text WHERE c.table_name = 'myTable' AND c.table_schema = 'mySchema' ORDER BY c.constraint_name, kcu.ordinal_position, ccu.column_name`,
        snowflake: `SELECT c.CONSTRAINT_CATALOG AS "constraintCatalog", c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_CATALOG AS "tableCatalog", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", r.DELETE_RULE AS "deleteAction", r.UPDATE_RULE AS "updateAction", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS fk ON r.UNIQUE_CONSTRAINT_CATALOG = fk.CONSTRAINT_CATALOG AND r.UNIQUE_CONSTRAINT_SCHEMA = fk.CONSTRAINT_SCHEMA AND r.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'mySchema' ORDER BY c.CONSTRAINT_NAME`,
        sqlite3: `SELECT sql FROM sqlite_master WHERE tbl_name = 'mySchema.myTable'`,
        'mariadb mysql': `SELECT c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_SCHEMA AS referencedTableSchema, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON c.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND c.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'mySchema' ORDER BY c.CONSTRAINT_NAME, kcu.ORDINAL_POSITION`,
      },
    );
  });

  it('produces a show constraints query for a table and default schema', () => {
    expectsql(
      () =>
        queryGenerator.showConstraintsQuery({
          tableName: 'myTable',
          schema: dialect.getDefaultSchema(),
        }),
      {
        db2: `SELECT TRIM(c.TABSCHEMA) AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", TRIM(c.TABSCHEMA) AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", TRIM(r.REFTABSCHEMA) AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteAction", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateAction", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON c.CONSTNAME = k.CONSTNAME AND c.TABNAME = k.TABNAME AND c.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'myTable' AND c.TABSCHEMA = 'DB2INST1' ORDER BY c.CONSTNAME, k.COLSEQ, fk.COLSEQ`,
        ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON c.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = CURRENT SCHEMA ORDER BY c.CONSTRAINT_NAME, k.ORDINAL_POSITION, fk.ORDINAL_POSITION`,
        mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableSchema, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT kc.[name] AS constraintName, kc.[type_desc] AS constraintType, kc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS [definition], null AS column_id FROM sys.key_constraints kc LEFT JOIN sys.indexes i ON kc.name = i.name LEFT JOIN sys.index_columns ic ON ic.index_id = i.index_id AND ic.object_id = kc.parent_object_id LEFT JOIN sys.columns c ON c.column_id = ic.column_id AND c.object_id = kc.parent_object_id UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.check_constraints c UNION ALL SELECT dc.[name] AS constraintName, dc.[type_desc] AS constraintType, dc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.default_constraints dc INNER JOIN sys.columns c ON dc.parent_column_id = c.column_id AND dc.parent_object_id = c.object_id UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_SCHEMA_NAME(k.[referenced_object_id]) as referencedTableSchema, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS [definition], rcol.column_id FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'dbo' AND t.name = N'myTable' ORDER BY c.constraintName, c.column_id`,
        postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", pg_get_expr(pgc.conbin, pgc.conrelid) AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON c.constraint_catalog = kcu.constraint_catalog AND c.constraint_schema = kcu.constraint_schema AND c.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN pg_constraint pgc ON c.constraint_name = pgc.conname AND c.table_schema = (SELECT nspname FROM pg_namespace WHERE oid = pgc.connamespace) AND c.table_name = pgc.conrelid::regclass::text WHERE c.table_name = 'myTable' AND c.table_schema = 'public' ORDER BY c.constraint_name, kcu.ordinal_position, ccu.column_name`,
        snowflake: `SELECT c.CONSTRAINT_CATALOG AS "constraintCatalog", c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_CATALOG AS "tableCatalog", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", r.DELETE_RULE AS "deleteAction", r.UPDATE_RULE AS "updateAction", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS fk ON r.UNIQUE_CONSTRAINT_CATALOG = fk.CONSTRAINT_CATALOG AND r.UNIQUE_CONSTRAINT_SCHEMA = fk.CONSTRAINT_SCHEMA AND r.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'PUBLIC' ORDER BY c.CONSTRAINT_NAME`,
        sqlite3: `SELECT sql FROM sqlite_master WHERE tbl_name = 'myTable'`,
        'mariadb mysql': `SELECT c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_SCHEMA AS referencedTableSchema, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON c.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND c.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'sequelize_test' ORDER BY c.CONSTRAINT_NAME, kcu.ORDINAL_POSITION`,
      },
    );
  });

  it('produces a show constraints query for a table and globally set schema', () => {
    const sequelizeSchema = createSequelizeInstance({ schema: 'mySchema' });
    const queryGeneratorSchema = sequelizeSchema.queryGenerator;

    expectsql(() => queryGeneratorSchema.showConstraintsQuery('myTable'), {
      db2: `SELECT TRIM(c.TABSCHEMA) AS "constraintSchema", c.CONSTNAME AS "constraintName", CASE c.TYPE WHEN 'P' THEN 'PRIMARY KEY' WHEN 'F' THEN 'FOREIGN KEY' WHEN 'K' THEN 'CHECK' WHEN 'U' THEN 'UNIQUE' ELSE NULL END AS "constraintType", TRIM(c.TABSCHEMA) AS "tableSchema", c.TABNAME AS "tableName", k.COLNAME AS "columnNames", TRIM(r.REFTABSCHEMA) AS "referencedTableSchema", r.REFTABNAME AS "referencedTableName", fk.COLNAME AS "referencedColumnNames", CASE r.DELETERULE WHEN 'A' THEN 'NO ACTION' WHEN 'C' THEN 'CASCADE' WHEN 'N' THEN 'SET NULL' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "deleteAction", CASE r.UPDATERULE WHEN 'A' THEN 'NO ACTION' WHEN 'R' THEN 'RESTRICT' ELSE NULL END AS "updateAction", ck.TEXT AS "definition" FROM SYSCAT.TABCONST c LEFT JOIN SYSCAT.REFERENCES r ON c.CONSTNAME = r.CONSTNAME AND c.TABNAME = r.TABNAME AND c.TABSCHEMA = r.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE k ON c.CONSTNAME = k.CONSTNAME AND c.TABNAME = k.TABNAME AND c.TABSCHEMA = k.TABSCHEMA LEFT JOIN SYSCAT.KEYCOLUSE fk ON r.REFKEYNAME = fk.CONSTNAME LEFT JOIN SYSCAT.CHECKS ck ON c.CONSTNAME = ck.CONSTNAME AND c.TABNAME = ck.TABNAME AND c.TABSCHEMA = ck.TABSCHEMA WHERE c.TABNAME = 'myTable' AND c.TABSCHEMA = 'mySchema' ORDER BY c.CONSTNAME, k.COLSEQ, fk.COLSEQ`,
      ibmi: `SELECT c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", k.COLUMN_NAME AS "columnNames", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", fk.COLUMN_NAME AS "referencedColumnNames", r.DELETE_RULE AS "deleteRule", r.UPDATE_RULE AS "updateRule", ch.CHECK_CLAUSE AS "definition", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM QSYS2.SYSCST c LEFT JOIN QSYS2.SYSREFCST r ON c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST k ON c.CONSTRAINT_NAME = k.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSKEYCST fk ON r.UNIQUE_CONSTRAINT_NAME = k.CONSTRAINT_NAME AND r.UNIQUE_CONSTRAINT_SCHEMA = k.CONSTRAINT_SCHEMA LEFT JOIN QSYS2.SYSCHKCST ch ON c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'mySchema' ORDER BY c.CONSTRAINT_NAME, k.ORDINAL_POSITION, fk.ORDINAL_POSITION`,
      mssql: `SELECT DB_NAME() AS constraintCatalog, s.[name] AS constraintSchema, c.constraintName, REPLACE(LEFT(c.constraintType, CHARINDEX('_CONSTRAINT', c.constraintType) - 1), '_', ' ') AS constraintType, DB_NAME() AS tableCatalog, s.[name] AS tableSchema, t.[name] AS tableName, c.columnNames, c.referencedTableSchema, c.referencedTableName, c.referencedColumnNames, c.deleteAction, c.updateAction, c.definition FROM sys.tables t INNER JOIN sys.schemas s ON t.schema_id = s.schema_id INNER JOIN (SELECT kc.[name] AS constraintName, kc.[type_desc] AS constraintType, kc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, null AS [definition], null AS column_id FROM sys.key_constraints kc LEFT JOIN sys.indexes i ON kc.name = i.name LEFT JOIN sys.index_columns ic ON ic.index_id = i.index_id AND ic.object_id = kc.parent_object_id LEFT JOIN sys.columns c ON c.column_id = ic.column_id AND c.object_id = kc.parent_object_id UNION ALL SELECT [name] AS constraintName, [type_desc] AS constraintType, [parent_object_id] AS constraintTableId, null AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.check_constraints c UNION ALL SELECT dc.[name] AS constraintName, dc.[type_desc] AS constraintType, dc.[parent_object_id] AS constraintTableId, c.[name] AS columnNames, null as referencedTableSchema, null AS referencedTableName, null AS referencedColumnNames, null AS deleteAction, null AS updateAction, [definition], null AS column_id FROM sys.default_constraints dc INNER JOIN sys.columns c ON dc.parent_column_id = c.column_id AND dc.parent_object_id = c.object_id UNION ALL SELECT k.[name] AS constraintName, k.[type_desc] AS constraintType, k.[parent_object_id] AS constraintTableId, fcol.[name] AS columnNames, OBJECT_SCHEMA_NAME(k.[referenced_object_id]) as referencedTableSchema, OBJECT_NAME(k.[referenced_object_id]) AS referencedTableName, rcol.[name] AS referencedColumnNames, k.[delete_referential_action_desc] AS deleteAction, k.[update_referential_action_desc] AS updateAction, null AS [definition], rcol.column_id FROM sys.foreign_keys k INNER JOIN sys.foreign_key_columns c ON k.[object_id] = c.constraint_object_id INNER JOIN sys.columns fcol ON c.parent_column_id = fcol.column_id AND c.parent_object_id = fcol.object_id INNER JOIN sys.columns rcol ON c.referenced_column_id = rcol.column_id AND c.referenced_object_id = rcol.object_id) c ON t.object_id = c.constraintTableId WHERE s.name = N'mySchema' AND t.name = N'myTable' ORDER BY c.constraintName, c.column_id`,
      postgres: `SELECT c.constraint_catalog AS "constraintCatalog", c.constraint_schema AS "constraintSchema", c.constraint_name AS "constraintName", c.constraint_type AS "constraintType", c.table_catalog AS "tableCatalog", c.table_schema AS "tableSchema", c.table_name AS "tableName", kcu.column_name AS "columnNames", ccu.table_schema AS "referencedTableSchema", ccu.table_name AS "referencedTableName", ccu.column_name AS "referencedColumnNames", r.delete_rule AS "deleteAction", r.update_rule AS "updateAction", pg_get_expr(pgc.conbin, pgc.conrelid) AS "definition", c.is_deferrable AS "isDeferrable", c.initially_deferred AS "initiallyDeferred" FROM INFORMATION_SCHEMA.table_constraints c LEFT JOIN INFORMATION_SCHEMA.referential_constraints r ON c.constraint_catalog = r.constraint_catalog AND c.constraint_schema = r.constraint_schema AND c.constraint_name = r.constraint_name LEFT JOIN INFORMATION_SCHEMA.key_column_usage kcu ON c.constraint_catalog = kcu.constraint_catalog AND c.constraint_schema = kcu.constraint_schema AND c.constraint_name = kcu.constraint_name LEFT JOIN information_schema.constraint_column_usage AS ccu ON r.constraint_catalog = ccu.constraint_catalog AND r.constraint_schema = ccu.constraint_schema AND r.constraint_name = ccu.constraint_name LEFT JOIN pg_constraint pgc ON c.constraint_name = pgc.conname AND c.table_schema = (SELECT nspname FROM pg_namespace WHERE oid = pgc.connamespace) AND c.table_name = pgc.conrelid::regclass::text WHERE c.table_name = 'myTable' AND c.table_schema = 'mySchema' ORDER BY c.constraint_name, kcu.ordinal_position, ccu.column_name`,
      snowflake: `SELECT c.CONSTRAINT_CATALOG AS "constraintCatalog", c.CONSTRAINT_SCHEMA AS "constraintSchema", c.CONSTRAINT_NAME AS "constraintName", c.CONSTRAINT_TYPE AS "constraintType", c.TABLE_CATALOG AS "tableCatalog", c.TABLE_SCHEMA AS "tableSchema", c.TABLE_NAME AS "tableName", fk.TABLE_SCHEMA AS "referencedTableSchema", fk.TABLE_NAME AS "referencedTableName", r.DELETE_RULE AS "deleteAction", r.UPDATE_RULE AS "updateAction", c.IS_DEFERRABLE AS "isDeferrable", c.INITIALLY_DEFERRED AS "initiallyDeferred" FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS fk ON r.UNIQUE_CONSTRAINT_CATALOG = fk.CONSTRAINT_CATALOG AND r.UNIQUE_CONSTRAINT_SCHEMA = fk.CONSTRAINT_SCHEMA AND r.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'mySchema' ORDER BY c.CONSTRAINT_NAME`,
      sqlite3: `SELECT sql FROM sqlite_master WHERE tbl_name = 'mySchema.myTable'`,
      'mariadb mysql': `SELECT c.CONSTRAINT_SCHEMA AS constraintSchema, c.CONSTRAINT_NAME AS constraintName, c.CONSTRAINT_TYPE AS constraintType, c.TABLE_SCHEMA AS tableSchema, c.TABLE_NAME AS tableName, kcu.COLUMN_NAME AS columnNames, kcu.REFERENCED_TABLE_SCHEMA AS referencedTableSchema, kcu.REFERENCED_TABLE_NAME AS referencedTableName, kcu.REFERENCED_COLUMN_NAME AS referencedColumnNames, r.DELETE_RULE AS deleteAction, r.UPDATE_RULE AS updateAction, ch.CHECK_CLAUSE AS definition FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS c LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS r ON c.CONSTRAINT_CATALOG = r.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = r.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = r.CONSTRAINT_NAME AND c.TABLE_NAME = r.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu ON c.CONSTRAINT_CATALOG = kcu.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = kcu.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME AND c.TABLE_NAME = kcu.TABLE_NAME LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS ch ON c.CONSTRAINT_CATALOG = ch.CONSTRAINT_CATALOG AND c.CONSTRAINT_SCHEMA = ch.CONSTRAINT_SCHEMA AND c.CONSTRAINT_NAME = ch.CONSTRAINT_NAME WHERE c.TABLE_NAME = 'myTable' AND c.TABLE_SCHEMA = 'mySchema' ORDER BY c.CONSTRAINT_NAME, kcu.ORDINAL_POSITION`,
    });
  });

  it('produces a show constraints query for a table with schema and custom delimiter argument', () => {
    // This test is only relevant for dialects that do not support schemas
    if (dialect.supports.schemas) {
      return;
    }

    expectsql(
      () =>
        queryGenerator.showConstraintsQuery({
          tableName: 'myTable',
          schema: 'mySchema',
          delimiter: 'custom',
        }),
      {
        sqlite3: `SELECT sql FROM sqlite_master WHERE tbl_name = 'mySchemacustommyTable'`,
      },
    );
  });
});
