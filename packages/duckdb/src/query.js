'use strict';

import { AbstractQuery, DatabaseError, UniqueConstraintError } from '@sequelize/core';
import { logger } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/logger.js';
import { isBigInt } from '@sequelize/utils';

const debug = logger.debugContext('sql:duckdb');

export class DuckDbQuery extends AbstractQuery {
  constructor(connection, sequelize, options) {
    super(connection, sequelize, { showWarnings: false, ...options });
  }

  async run(sql, parameters) {
    this.sql = sql;
    const complete = this._logQuery(sql, debug, parameters);

    if (sql.startsWith('DROP TABLE')) {
      const sequence_prefix = sql
        .match(/^DROP TABLE IF EXISTS "([^ ]+)"/)[1]
        .replaceAll('.', '_')
        .replaceAll('"', '');

      const sequences = [];
      // clean up all the table's sequences
      sequences.push(
        this.connection
          .all(
            'SELECT sequence_name FROM duckdb_sequences() WHERE starts_with(sequence_name, ?)',
            sequence_prefix,
          )
          .then(seqResult => {
            return seqResult;
          }),
      );

      return Promise.all(
        sequences.map(seqPromise =>
          seqPromise.then(sequence => {
            if (sequence && sequence.length > 0 && 'sequence_name' in sequence[0]) {
              return this.connection.all(`DROP SEQUENCE ${sequence[0].sequence_name} CASCADE`);
            }
          }),
        ),
      ).then(() => this.runQueryInternal(sql, parameters, complete));
    }

    return this.runQueryInternal(sql, parameters, complete);
  }

  formatError(err) {
    if (
      err.errorType === 'Constraint' &&
      (err.message.includes('Duplicate key') || err.message.includes('duplicate key'))
    ) {
      // retry 'properly bind parameters on extra retries' test has a hardcoded condition with "Validation"
      return new UniqueConstraintError({ message: `Validation error: ${err.message}`, cause: err });
    }

    return new DatabaseError(err);
  }

  // Sequelize really wants untyped string values when used without a model
  postprocessData(data, model) {
    if (!model) {
      // Sequelize really wants plan text data in the absence of a model
      for (const i in data) {
        for (const key in data[i]) {
          if (data[i][key] instanceof Date) {
            data[i][key] = data[i][key].toISOString();
          }
        }
      }
    }

    return data;
  }

  async runQueryInternal(sql, parameters, loggingCompleteCallback) {
    let dataPromise;
    if (parameters) {
      // for some reason implementing toBindableValue on BigInt does not work to do this conversion
      const convertedParameters = parameters.map(p => {
        if (isBigInt(p)) {
          // BigInt binds as null in duckdb-node
          return p.toString();
        }

        return p;
      });
      dataPromise = this.connection.all(sql, ...convertedParameters);
    } else {
      dataPromise = this.connection.all(sql);
    }

    if (this.isSelectQuery()) {
      return dataPromise.then(
        data => {
          loggingCompleteCallback();

          return this.handleSelectQuery(this.postprocessData(data, this.model?.modelDefinition));
        },
        error => {
          throw this.formatError(error);
        },
      );
    }

    return dataPromise.then(
      data => {
        loggingCompleteCallback();

        return this.processResults(data);
      },
      error => {
        throw this.formatError(error);
      },
    );
  }

  // Converts non-SELECT query results to a format expected by the framework.
  processResults(data) {
    // this is not amazing since row count can be larger than Number but Sequelize expects a Number...
    let rowsUpdated = 0;
    if (Array.isArray(data)) {
      if (data.length > 0 && Object.hasOwn(data[0], 'Count')) {
        // Update or Delete query
        rowsUpdated = Number(data[0].Count);
      } else {
        // Upsert query with RETURNING clause will return rows
        rowsUpdated = data.length;
      }
    }

    let result = this.instance;

    if (this.isInsertQuery(data, {}) || this.isUpsertQuery()) {
      this.handleInsertQuery(data, {});
      const modelDefinition = this.model?.modelDefinition;

      if (!this.instance) {
        // return autogenerated fields, so a model can be constructed
        result = data;
      } else if (Array.isArray(data) && data.length > 0) {
        // update model with values returned from the database
        for (const column of Object.keys(data[0])) {
          const modelColumn = modelDefinition.columns.get(column);
          if (modelColumn) {
            const val = data[0][column]
              ? modelColumn.type.parseDatabaseValue(data[0][column])
              : data[0][column];
            this.instance.set(modelColumn.attributeName, val, {
              raw: true,
              comesFromDatabase: true,
            });
          }
        }
      }

      // Second value for upsert should be whether the row was inserted, but there is no way to know
      return this.isUpsertQuery() ? [result, null] : [result, rowsUpdated];
    }

    if (this.isUpdateQuery()) {
      return [result, rowsUpdated];
    }

    if (this.isShowOrDescribeQuery() || this.sql.includes('from duckdb_columns()')) {
      const describeResult = {};
      for (const column of data) {
        describeResult[column.column_name] = {
          type: column.column_type,
          allowNull: column.null === 'YES' || column.is_nullable,
          defaultValue: column.default || null,
          primaryKey: column.key === 'PRI' || column.is_primary_key || false,
          unique: false,
        };
      }

      return describeResult;
    }

    if (this.isRawQuery()) {
      return [data, rowsUpdated];
    }

    if (this.isShowConstraintsQuery() || this.isShowIndexesQuery()) {
      // those are not useful right now because constraints/indexes are unsupported
      // but they'll still return an empty array when invoked
      return data;
    }

    if (this.isBulkUpdateQuery() || this.isDeleteQuery()) {
      // TBD: check what format is expected to be returned - just the row count?
      return rowsUpdated;
    }

    // TBD: is fallback needed?
    return [data, rowsUpdated];
  }
}
