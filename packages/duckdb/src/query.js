'use strict';

import {
  AbstractQuery, DatabaseError, UniqueConstraintError,
} from '@sequelize/core';
import { logger } from '@sequelize/core/_non-semver-use-at-your-own-risk_/utils/logger.js';
import { isBigInt } from "@sequelize/utils";

const debug = logger.debugContext('sql:duckdb');

export class DuckDbQuery extends AbstractQuery {
  constructor(connection, sequelize, options) {
    super(connection, sequelize, { showWarnings: false, ...options });
  }

  async run(sql, parameters) {
    this.sql = sql;
    const complete = this._logQuery(sql, debug, parameters);

    if (sql.startsWith("DROP TABLE")) {
      const sequence_prefix = sql.match(/^DROP TABLE IF EXISTS "([^ ]+)"/)[1]
          .replaceAll('.', '_')
          .replaceAll('"', '');

      const sequences = [];
      // clean up all the table's sequences
      sequences.push(this.connection.all(
          "SELECT sequence_name FROM duckdb_sequences() WHERE starts_with(sequence_name, ?)",
          sequence_prefix
      ).then(seqResult => {
        return seqResult;
      }));

      return Promise.all(
        sequences.map(seqPromise => seqPromise.then(sequence => {
          if (sequence && sequence.length > 0 && "sequence_name" in sequence[0]) {
            return this.connection.all("DROP SEQUENCE " + sequence[0].sequence_name + " CASCADE");
          }

          return Promise.resolve();
        }))
      ).then(() => this.runQueryInternal(sql, parameters, complete));
    }

    return this.runQueryInternal(sql, parameters, complete);
  }

  formatError(err) {
    if (err.errorType === 'Constraint' &&
        (err.message.includes("Duplicate key") || err.message.includes("duplicate key"))) {
      // retry 'properly bind parameters on extra retries' test has a hardcoded condition with "Validation"
      return new UniqueConstraintError({ message: `Validation error: ${err.message}`, cause: err} );
    }


    return new DatabaseError(err);
  }

  // This is slow and terrible, but Sequelize really wants untyped string values when used without a model
  postprocessData(data, model) {
    if (!model) {
      // Sequelize really wants plan text data in the absence of a model
      for (const i in data) {
        for (const key in data[i]) {
          if (data[i][key] instanceof Date) {
            data[i][key] = data[i][key].toISOString();
          }

        }
      }
    }
    return data;
  }

  async runQueryInternal(sql, parameters, loggingCompleteCallback) {
    let dataPromise;
    if (parameters) {
      // TODO: move this into overrides
      const convertedParameters = parameters.map(p => {
        if (isBigInt(p)) {
          // TBD: BigInt binds as null in duckdb-node. check if Neo does better.
          return p.toString();
        }

        return p;
      });
      dataPromise = this.connection.all(sql, ...convertedParameters);
    } else {
      dataPromise = this.connection.all(sql);
    }

    if (this.isSelectQuery()) {
      return dataPromise.then(data => {
        loggingCompleteCallback();

        return this.handleSelectQuery(this.postprocessData(data, this.model?.modelDefinition));
      }, error => {
        throw this.formatError(error);
      });
    }

    return dataPromise.then(data => {
      loggingCompleteCallback();

      return this.processResults(data);
    }, error => {
      throw this.formatError(error)
    });
  }

  // TBD: comment better; no longer async
  processResults(data) {
    // this is not amazing since row count can be larger than Number but Sequelize expects a Number...
    let rowsUpdated = 0;
    if (Array.isArray(data)) {
      if (data.length > 0 && Object.hasOwn(data[0], 'Count')) {
        // Update or Delete query
        rowsUpdated = Number(data[0].Count);
      } else {
        // Upsert query with RETURNING clause will return rows
        rowsUpdated = data.length;
      }
    }

    let result = this.instance;

    if (this.isInsertQuery(data, {}) || this.isUpsertQuery()) {

      this.handleInsertQuery(data, {});
      const modelDefinition = this.model?.modelDefinition;

      if (!this.instance) {
        // return autogenerated fields, so a model can be constructed
        result = data;
      } else if (Array.isArray(data) && data.length > 0) {
        // update model with values returned from the database
        for (const column of Object.keys(data[0])) {
          const modelColumn = modelDefinition.columns.get(column);
          if (modelColumn) {
            const val = data[0][column] ? modelColumn.type.parseDatabaseValue(data[0][column]) : data[0][column];
            this.instance.set(modelColumn.attributeName, val, {
              raw: true,
              comesFromDatabase: true,
            });
          }
        }
      }

      // Second value for upsert should be whether the row was inserted, but there is no way to know
      return this.isUpsertQuery() ? [result, null] : [result, rowsUpdated];
    }

    if (this.isUpdateQuery()) {
      return [result, rowsUpdated];
    }

    if (this.isShowOrDescribeQuery() || this.sql.includes('FROM duckdb_columns()')) {
      const describeResult = {};
      for (const column of data) {
        describeResult[column.column_name] = {
          type: column.column_type,
          allowNull: column.null === 'YES' || column.is_nullable,
          defaultValue: column.default || null,
          primaryKey: column.key || false,
          unique: false,
        };
        if (column.comment?.includes('PRIMARY KEY')) {
          describeResult[column.column_name].primaryKey = true;
        }
      }

      return describeResult;
    }

    if (this.isRawQuery()) {
      return [data, rowsUpdated];
    }

    if (this.isShowConstraintsQuery() || this.isShowIndexesQuery()) {
      // those are not useful right now because constraints/indexes are unsupported
      // but they'll still return an empty array when invoked
      return data;
    }

    if (this.isBulkUpdateQuery() || this.isDeleteQuery()) {
      // TBD: check what format is expected to be returned - just the row count?
      return rowsUpdated;
    }

    // TBD: is fallback needed?
    return [data, rowsUpdated];
  }
}
